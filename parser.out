Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    FOR
    AND
    OR

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID COLON vars main function
Rule 2     program -> PROGRAM ID COLON main function
Rule 3     program -> PROGRAM ID COLON vars main
Rule 4     program -> PROGRAM ID COLON main
Rule 5     main -> nomMain LPAREN RPAREN LBRACE bloqueAux RBRACE
Rule 6     main -> nomMain LPAREN RPAREN LBRACE vars bloqueAux RBRACE
Rule 7     nomMain -> MAIN
Rule 8     vars -> VAR varAux1
Rule 9     varAux1 -> tipo varAux2 SEMICOLON
Rule 10    varAux1 -> tipo varAux2 SEMICOLON varAux1
Rule 11    varAux2 -> ID
Rule 12    varAux2 -> ID COMA varAux2
Rule 13    tipo -> INT
Rule 14    tipo -> FLOAT
Rule 15    tipo -> CHAR
Rule 16    tipoFunc -> INT
Rule 17    tipoFunc -> FLOAT
Rule 18    tipoFunc -> CHAR
Rule 19    tipoFunc -> VOID
Rule 20    bloque -> LBRACE RBRACE
Rule 21    bloque -> LBRACE bloqueAux RBRACE
Rule 22    function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE
Rule 23    function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE
Rule 24    function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE function
Rule 25    function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE function
Rule 26    function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE
Rule 27    function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE
Rule 28    function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE function
Rule 29    function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE function
Rule 30    param -> tipo ID
Rule 31    param -> tipo ID COMA param
Rule 32    nomFunc -> ID
Rule 33    bloqueAux -> estatuto
Rule 34    bloqueAux -> estatuto bloqueAux
Rule 35    while -> WHILE LPAREN expresion RPAREN bloque
Rule 36    estatuto -> asignacion
Rule 37    estatuto -> condicion
Rule 38    estatuto -> escritura
Rule 39    estatuto -> while
Rule 40    estatuto -> comparacion
Rule 41    asignacion -> ID push_id EQUAL push_poper expresion SEMICOLON
Rule 42    comparacion -> ID push_id DOUBLEEQUAL push_poper expresion SEMICOLON
Rule 43    condicion -> IF LPAREN expresion RPAREN bloque SEMICOLON
Rule 44    condicion -> IF LPAREN expresion RPAREN bloque ELSE bloque SEMICOLON
Rule 45    escritura -> PRINT LPAREN escrituraAux RPAREN SEMICOLON
Rule 46    escrituraAux -> expresion
Rule 47    escrituraAux -> CTE_STRING
Rule 48    escrituraAux -> expresion COMA escrituraAux
Rule 49    escrituraAux -> CTE_STRING COMA escrituraAux
Rule 50    expresion -> exp
Rule 51    expresion -> exp LOWERTHAN push_poper exp
Rule 52    expresion -> exp MORETHAN push_poper exp
Rule 53    expresion -> exp DIFFERENT push_poper exp
Rule 54    exp -> termino
Rule 55    exp -> termino PLUS push_poper exp
Rule 56    exp -> termino MINUS push_poper exp
Rule 57    quad_Fact -> <empty>
Rule 58    termino -> factor
Rule 59    termino -> factor TIMES push_poper termino
Rule 60    termino -> factor DIVIDE push_poper termino
Rule 61    factor -> LPAREN expresion RPAREN
Rule 62    factor -> factorAux
Rule 63    factorAux -> PLUS push_poper var_cte
Rule 64    factorAux -> MINUS push_poper var_cte
Rule 65    factorAux -> var_cte
Rule 66    push_id -> <empty>
Rule 67    push_cte -> <empty>
Rule 68    push_poper -> <empty>
Rule 69    var_cte -> ID push_id
Rule 70    var_cte -> CTE_I push_cte
Rule 71    var_cte -> CTE_F push_cte

Terminals, with rules where they appear

AND                  : 
CHAR                 : 15 18
COLON                : 1 2 3 4
COMA                 : 12 31 48 49
CTE_F                : 71
CTE_I                : 70
CTE_STRING           : 47 49
DIFFERENT            : 53
DIVIDE               : 60
DOUBLEEQUAL          : 42
ELSE                 : 44
EQUAL                : 41
FLOAT                : 14 17
FOR                  : 
FUNCTION             : 22 23 24 25 26 27 28 29
ID                   : 1 2 3 4 11 12 30 31 32 41 42 69
IF                   : 43 44
INT                  : 13 16
LBRACE               : 5 6 20 21 22 23 24 25 26 27 28 29
LOWERTHAN            : 51
LPAREN               : 5 6 22 23 24 25 26 27 28 29 35 43 44 45 61
MAIN                 : 7
MINUS                : 56 64
MORETHAN             : 52
OR                   : 
PLUS                 : 55 63
PRINT                : 45
PROGRAM              : 1 2 3 4
RBRACE               : 5 6 20 21 22 23 24 25 26 27 28 29
RPAREN               : 5 6 22 23 24 25 26 27 28 29 35 43 44 45 61
SEMICOLON            : 9 10 41 42 43 44 45
TIMES                : 59
VAR                  : 8
VOID                 : 19
WHILE                : 35
error                : 

Nonterminals, with rules where they appear

asignacion           : 36
bloque               : 35 43 44 44
bloqueAux            : 5 6 21 23 25 27 29 34
comparacion          : 40
condicion            : 37
escritura            : 38
escrituraAux         : 45 48 49
estatuto             : 33 34
exp                  : 50 51 51 52 52 53 53 55 56
expresion            : 35 41 42 43 44 46 48 61
factor               : 58 59 60
factorAux            : 62
function             : 1 2 24 25 28 29
main                 : 1 2 3 4
nomFunc              : 22 23 24 25 26 27 28 29
nomMain              : 5 6
param                : 26 27 28 29 31
program              : 0
push_cte             : 70 71
push_id              : 41 42 69
push_poper           : 41 42 51 52 53 55 56 59 60 63 64
quad_Fact            : 
termino              : 54 55 56 59 60
tipo                 : 9 10 30 31
tipoFunc             : 22 23 24 25 26 27 28 29
varAux1              : 8 10
varAux2              : 9 10 12
var_cte              : 63 64 65
vars                 : 1 3 6 23 25 27 29
while                : 39

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID COLON vars main function
    (2) program -> . PROGRAM ID COLON main function
    (3) program -> . PROGRAM ID COLON vars main
    (4) program -> . PROGRAM ID COLON main

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID COLON vars main function
    (2) program -> PROGRAM . ID COLON main function
    (3) program -> PROGRAM . ID COLON vars main
    (4) program -> PROGRAM . ID COLON main

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . COLON vars main function
    (2) program -> PROGRAM ID . COLON main function
    (3) program -> PROGRAM ID . COLON vars main
    (4) program -> PROGRAM ID . COLON main

    COLON           shift and go to state 4


state 4

    (1) program -> PROGRAM ID COLON . vars main function
    (2) program -> PROGRAM ID COLON . main function
    (3) program -> PROGRAM ID COLON . vars main
    (4) program -> PROGRAM ID COLON . main
    (8) vars -> . VAR varAux1
    (5) main -> . nomMain LPAREN RPAREN LBRACE bloqueAux RBRACE
    (6) main -> . nomMain LPAREN RPAREN LBRACE vars bloqueAux RBRACE
    (7) nomMain -> . MAIN

    VAR             shift and go to state 8
    MAIN            shift and go to state 6

    vars                           shift and go to state 5
    nomMain                        shift and go to state 7
    main                           shift and go to state 9

state 5

    (1) program -> PROGRAM ID COLON vars . main function
    (3) program -> PROGRAM ID COLON vars . main
    (5) main -> . nomMain LPAREN RPAREN LBRACE bloqueAux RBRACE
    (6) main -> . nomMain LPAREN RPAREN LBRACE vars bloqueAux RBRACE
    (7) nomMain -> . MAIN

    MAIN            shift and go to state 6

    nomMain                        shift and go to state 7
    main                           shift and go to state 10

state 6

    (7) nomMain -> MAIN .

    LPAREN          reduce using rule 7 (nomMain -> MAIN .)


state 7

    (5) main -> nomMain . LPAREN RPAREN LBRACE bloqueAux RBRACE
    (6) main -> nomMain . LPAREN RPAREN LBRACE vars bloqueAux RBRACE

    LPAREN          shift and go to state 11


state 8

    (8) vars -> VAR . varAux1
    (9) varAux1 -> . tipo varAux2 SEMICOLON
    (10) varAux1 -> . tipo varAux2 SEMICOLON varAux1
    (13) tipo -> . INT
    (14) tipo -> . FLOAT
    (15) tipo -> . CHAR

    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    CHAR            shift and go to state 12

    varAux1                        shift and go to state 16
    tipo                           shift and go to state 13

state 9

    (2) program -> PROGRAM ID COLON main . function
    (4) program -> PROGRAM ID COLON main .
    (22) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE
    (23) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE
    (24) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE function
    (25) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE function
    (26) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE
    (27) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE
    (28) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE function
    (29) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE function

    $end            reduce using rule 4 (program -> PROGRAM ID COLON main .)
    FUNCTION        shift and go to state 18

    function                       shift and go to state 17

state 10

    (1) program -> PROGRAM ID COLON vars main . function
    (3) program -> PROGRAM ID COLON vars main .
    (22) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE
    (23) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE
    (24) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE function
    (25) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE function
    (26) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE
    (27) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE
    (28) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE function
    (29) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE function

    $end            reduce using rule 3 (program -> PROGRAM ID COLON vars main .)
    FUNCTION        shift and go to state 18

    function                       shift and go to state 19

state 11

    (5) main -> nomMain LPAREN . RPAREN LBRACE bloqueAux RBRACE
    (6) main -> nomMain LPAREN . RPAREN LBRACE vars bloqueAux RBRACE

    RPAREN          shift and go to state 20


state 12

    (15) tipo -> CHAR .

    ID              reduce using rule 15 (tipo -> CHAR .)


state 13

    (9) varAux1 -> tipo . varAux2 SEMICOLON
    (10) varAux1 -> tipo . varAux2 SEMICOLON varAux1
    (11) varAux2 -> . ID
    (12) varAux2 -> . ID COMA varAux2

    ID              shift and go to state 22

    varAux2                        shift and go to state 21

state 14

    (13) tipo -> INT .

    ID              reduce using rule 13 (tipo -> INT .)


state 15

    (14) tipo -> FLOAT .

    ID              reduce using rule 14 (tipo -> FLOAT .)


state 16

    (8) vars -> VAR varAux1 .

    ID              reduce using rule 8 (vars -> VAR varAux1 .)
    IF              reduce using rule 8 (vars -> VAR varAux1 .)
    PRINT           reduce using rule 8 (vars -> VAR varAux1 .)
    WHILE           reduce using rule 8 (vars -> VAR varAux1 .)
    MAIN            reduce using rule 8 (vars -> VAR varAux1 .)


state 17

    (2) program -> PROGRAM ID COLON main function .

    $end            reduce using rule 2 (program -> PROGRAM ID COLON main function .)


state 18

    (22) function -> FUNCTION . tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE
    (23) function -> FUNCTION . tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE
    (24) function -> FUNCTION . tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE function
    (25) function -> FUNCTION . tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE function
    (26) function -> FUNCTION . tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE
    (27) function -> FUNCTION . tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE
    (28) function -> FUNCTION . tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE function
    (29) function -> FUNCTION . tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE function
    (16) tipoFunc -> . INT
    (17) tipoFunc -> . FLOAT
    (18) tipoFunc -> . CHAR
    (19) tipoFunc -> . VOID

    INT             shift and go to state 23
    FLOAT           shift and go to state 25
    CHAR            shift and go to state 26
    VOID            shift and go to state 24

    tipoFunc                       shift and go to state 27

state 19

    (1) program -> PROGRAM ID COLON vars main function .

    $end            reduce using rule 1 (program -> PROGRAM ID COLON vars main function .)


state 20

    (5) main -> nomMain LPAREN RPAREN . LBRACE bloqueAux RBRACE
    (6) main -> nomMain LPAREN RPAREN . LBRACE vars bloqueAux RBRACE

    LBRACE          shift and go to state 28


state 21

    (9) varAux1 -> tipo varAux2 . SEMICOLON
    (10) varAux1 -> tipo varAux2 . SEMICOLON varAux1

    SEMICOLON       shift and go to state 29


state 22

    (11) varAux2 -> ID .
    (12) varAux2 -> ID . COMA varAux2

    SEMICOLON       reduce using rule 11 (varAux2 -> ID .)
    COMA            shift and go to state 30


state 23

    (16) tipoFunc -> INT .

    ID              reduce using rule 16 (tipoFunc -> INT .)


state 24

    (19) tipoFunc -> VOID .

    ID              reduce using rule 19 (tipoFunc -> VOID .)


state 25

    (17) tipoFunc -> FLOAT .

    ID              reduce using rule 17 (tipoFunc -> FLOAT .)


state 26

    (18) tipoFunc -> CHAR .

    ID              reduce using rule 18 (tipoFunc -> CHAR .)


state 27

    (22) function -> FUNCTION tipoFunc . nomFunc LPAREN RPAREN LBRACE RBRACE
    (23) function -> FUNCTION tipoFunc . nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE
    (24) function -> FUNCTION tipoFunc . nomFunc LPAREN RPAREN LBRACE RBRACE function
    (25) function -> FUNCTION tipoFunc . nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE function
    (26) function -> FUNCTION tipoFunc . nomFunc LPAREN param RPAREN LBRACE RBRACE
    (27) function -> FUNCTION tipoFunc . nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE
    (28) function -> FUNCTION tipoFunc . nomFunc LPAREN param RPAREN LBRACE RBRACE function
    (29) function -> FUNCTION tipoFunc . nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE function
    (32) nomFunc -> . ID

    ID              shift and go to state 32

    nomFunc                        shift and go to state 31

state 28

    (5) main -> nomMain LPAREN RPAREN LBRACE . bloqueAux RBRACE
    (6) main -> nomMain LPAREN RPAREN LBRACE . vars bloqueAux RBRACE
    (33) bloqueAux -> . estatuto
    (34) bloqueAux -> . estatuto bloqueAux
    (8) vars -> . VAR varAux1
    (36) estatuto -> . asignacion
    (37) estatuto -> . condicion
    (38) estatuto -> . escritura
    (39) estatuto -> . while
    (40) estatuto -> . comparacion
    (41) asignacion -> . ID push_id EQUAL push_poper expresion SEMICOLON
    (43) condicion -> . IF LPAREN expresion RPAREN bloque SEMICOLON
    (44) condicion -> . IF LPAREN expresion RPAREN bloque ELSE bloque SEMICOLON
    (45) escritura -> . PRINT LPAREN escrituraAux RPAREN SEMICOLON
    (35) while -> . WHILE LPAREN expresion RPAREN bloque
    (42) comparacion -> . ID push_id DOUBLEEQUAL push_poper expresion SEMICOLON

    VAR             shift and go to state 8
    ID              shift and go to state 37
    IF              shift and go to state 38
    PRINT           shift and go to state 34
    WHILE           shift and go to state 40

    vars                           shift and go to state 33
    asignacion                     shift and go to state 39
    estatuto                       shift and go to state 35
    while                          shift and go to state 42
    bloqueAux                      shift and go to state 41
    condicion                      shift and go to state 36
    comparacion                    shift and go to state 43
    escritura                      shift and go to state 44

state 29

    (9) varAux1 -> tipo varAux2 SEMICOLON .
    (10) varAux1 -> tipo varAux2 SEMICOLON . varAux1
    (9) varAux1 -> . tipo varAux2 SEMICOLON
    (10) varAux1 -> . tipo varAux2 SEMICOLON varAux1
    (13) tipo -> . INT
    (14) tipo -> . FLOAT
    (15) tipo -> . CHAR

    MAIN            reduce using rule 9 (varAux1 -> tipo varAux2 SEMICOLON .)
    ID              reduce using rule 9 (varAux1 -> tipo varAux2 SEMICOLON .)
    IF              reduce using rule 9 (varAux1 -> tipo varAux2 SEMICOLON .)
    PRINT           reduce using rule 9 (varAux1 -> tipo varAux2 SEMICOLON .)
    WHILE           reduce using rule 9 (varAux1 -> tipo varAux2 SEMICOLON .)
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    CHAR            shift and go to state 12

    varAux1                        shift and go to state 45
    tipo                           shift and go to state 13

state 30

    (12) varAux2 -> ID COMA . varAux2
    (11) varAux2 -> . ID
    (12) varAux2 -> . ID COMA varAux2

    ID              shift and go to state 22

    varAux2                        shift and go to state 46

state 31

    (22) function -> FUNCTION tipoFunc nomFunc . LPAREN RPAREN LBRACE RBRACE
    (23) function -> FUNCTION tipoFunc nomFunc . LPAREN RPAREN LBRACE vars bloqueAux RBRACE
    (24) function -> FUNCTION tipoFunc nomFunc . LPAREN RPAREN LBRACE RBRACE function
    (25) function -> FUNCTION tipoFunc nomFunc . LPAREN RPAREN LBRACE vars bloqueAux RBRACE function
    (26) function -> FUNCTION tipoFunc nomFunc . LPAREN param RPAREN LBRACE RBRACE
    (27) function -> FUNCTION tipoFunc nomFunc . LPAREN param RPAREN LBRACE vars bloqueAux RBRACE
    (28) function -> FUNCTION tipoFunc nomFunc . LPAREN param RPAREN LBRACE RBRACE function
    (29) function -> FUNCTION tipoFunc nomFunc . LPAREN param RPAREN LBRACE vars bloqueAux RBRACE function

    LPAREN          shift and go to state 47


state 32

    (32) nomFunc -> ID .

    LPAREN          reduce using rule 32 (nomFunc -> ID .)


state 33

    (6) main -> nomMain LPAREN RPAREN LBRACE vars . bloqueAux RBRACE
    (33) bloqueAux -> . estatuto
    (34) bloqueAux -> . estatuto bloqueAux
    (36) estatuto -> . asignacion
    (37) estatuto -> . condicion
    (38) estatuto -> . escritura
    (39) estatuto -> . while
    (40) estatuto -> . comparacion
    (41) asignacion -> . ID push_id EQUAL push_poper expresion SEMICOLON
    (43) condicion -> . IF LPAREN expresion RPAREN bloque SEMICOLON
    (44) condicion -> . IF LPAREN expresion RPAREN bloque ELSE bloque SEMICOLON
    (45) escritura -> . PRINT LPAREN escrituraAux RPAREN SEMICOLON
    (35) while -> . WHILE LPAREN expresion RPAREN bloque
    (42) comparacion -> . ID push_id DOUBLEEQUAL push_poper expresion SEMICOLON

    ID              shift and go to state 37
    IF              shift and go to state 38
    PRINT           shift and go to state 34
    WHILE           shift and go to state 40

    asignacion                     shift and go to state 39
    estatuto                       shift and go to state 35
    while                          shift and go to state 42
    bloqueAux                      shift and go to state 48
    condicion                      shift and go to state 36
    comparacion                    shift and go to state 43
    escritura                      shift and go to state 44

state 34

    (45) escritura -> PRINT . LPAREN escrituraAux RPAREN SEMICOLON

    LPAREN          shift and go to state 49


state 35

    (33) bloqueAux -> estatuto .
    (34) bloqueAux -> estatuto . bloqueAux
    (33) bloqueAux -> . estatuto
    (34) bloqueAux -> . estatuto bloqueAux
    (36) estatuto -> . asignacion
    (37) estatuto -> . condicion
    (38) estatuto -> . escritura
    (39) estatuto -> . while
    (40) estatuto -> . comparacion
    (41) asignacion -> . ID push_id EQUAL push_poper expresion SEMICOLON
    (43) condicion -> . IF LPAREN expresion RPAREN bloque SEMICOLON
    (44) condicion -> . IF LPAREN expresion RPAREN bloque ELSE bloque SEMICOLON
    (45) escritura -> . PRINT LPAREN escrituraAux RPAREN SEMICOLON
    (35) while -> . WHILE LPAREN expresion RPAREN bloque
    (42) comparacion -> . ID push_id DOUBLEEQUAL push_poper expresion SEMICOLON

    RBRACE          reduce using rule 33 (bloqueAux -> estatuto .)
    ID              shift and go to state 37
    IF              shift and go to state 38
    PRINT           shift and go to state 34
    WHILE           shift and go to state 40

    asignacion                     shift and go to state 39
    estatuto                       shift and go to state 35
    bloqueAux                      shift and go to state 50
    while                          shift and go to state 42
    condicion                      shift and go to state 36
    comparacion                    shift and go to state 43
    escritura                      shift and go to state 44

state 36

    (37) estatuto -> condicion .

    ID              reduce using rule 37 (estatuto -> condicion .)
    IF              reduce using rule 37 (estatuto -> condicion .)
    PRINT           reduce using rule 37 (estatuto -> condicion .)
    WHILE           reduce using rule 37 (estatuto -> condicion .)
    RBRACE          reduce using rule 37 (estatuto -> condicion .)


state 37

    (41) asignacion -> ID . push_id EQUAL push_poper expresion SEMICOLON
    (42) comparacion -> ID . push_id DOUBLEEQUAL push_poper expresion SEMICOLON
    (66) push_id -> .

    EQUAL           reduce using rule 66 (push_id -> .)
    DOUBLEEQUAL     reduce using rule 66 (push_id -> .)

    push_id                        shift and go to state 51

state 38

    (43) condicion -> IF . LPAREN expresion RPAREN bloque SEMICOLON
    (44) condicion -> IF . LPAREN expresion RPAREN bloque ELSE bloque SEMICOLON

    LPAREN          shift and go to state 52


state 39

    (36) estatuto -> asignacion .

    ID              reduce using rule 36 (estatuto -> asignacion .)
    IF              reduce using rule 36 (estatuto -> asignacion .)
    PRINT           reduce using rule 36 (estatuto -> asignacion .)
    WHILE           reduce using rule 36 (estatuto -> asignacion .)
    RBRACE          reduce using rule 36 (estatuto -> asignacion .)


state 40

    (35) while -> WHILE . LPAREN expresion RPAREN bloque

    LPAREN          shift and go to state 53


state 41

    (5) main -> nomMain LPAREN RPAREN LBRACE bloqueAux . RBRACE

    RBRACE          shift and go to state 54


state 42

    (39) estatuto -> while .

    ID              reduce using rule 39 (estatuto -> while .)
    IF              reduce using rule 39 (estatuto -> while .)
    PRINT           reduce using rule 39 (estatuto -> while .)
    WHILE           reduce using rule 39 (estatuto -> while .)
    RBRACE          reduce using rule 39 (estatuto -> while .)


state 43

    (40) estatuto -> comparacion .

    ID              reduce using rule 40 (estatuto -> comparacion .)
    IF              reduce using rule 40 (estatuto -> comparacion .)
    PRINT           reduce using rule 40 (estatuto -> comparacion .)
    WHILE           reduce using rule 40 (estatuto -> comparacion .)
    RBRACE          reduce using rule 40 (estatuto -> comparacion .)


state 44

    (38) estatuto -> escritura .

    ID              reduce using rule 38 (estatuto -> escritura .)
    IF              reduce using rule 38 (estatuto -> escritura .)
    PRINT           reduce using rule 38 (estatuto -> escritura .)
    WHILE           reduce using rule 38 (estatuto -> escritura .)
    RBRACE          reduce using rule 38 (estatuto -> escritura .)


state 45

    (10) varAux1 -> tipo varAux2 SEMICOLON varAux1 .

    MAIN            reduce using rule 10 (varAux1 -> tipo varAux2 SEMICOLON varAux1 .)
    ID              reduce using rule 10 (varAux1 -> tipo varAux2 SEMICOLON varAux1 .)
    IF              reduce using rule 10 (varAux1 -> tipo varAux2 SEMICOLON varAux1 .)
    PRINT           reduce using rule 10 (varAux1 -> tipo varAux2 SEMICOLON varAux1 .)
    WHILE           reduce using rule 10 (varAux1 -> tipo varAux2 SEMICOLON varAux1 .)


state 46

    (12) varAux2 -> ID COMA varAux2 .

    SEMICOLON       reduce using rule 12 (varAux2 -> ID COMA varAux2 .)


state 47

    (22) function -> FUNCTION tipoFunc nomFunc LPAREN . RPAREN LBRACE RBRACE
    (23) function -> FUNCTION tipoFunc nomFunc LPAREN . RPAREN LBRACE vars bloqueAux RBRACE
    (24) function -> FUNCTION tipoFunc nomFunc LPAREN . RPAREN LBRACE RBRACE function
    (25) function -> FUNCTION tipoFunc nomFunc LPAREN . RPAREN LBRACE vars bloqueAux RBRACE function
    (26) function -> FUNCTION tipoFunc nomFunc LPAREN . param RPAREN LBRACE RBRACE
    (27) function -> FUNCTION tipoFunc nomFunc LPAREN . param RPAREN LBRACE vars bloqueAux RBRACE
    (28) function -> FUNCTION tipoFunc nomFunc LPAREN . param RPAREN LBRACE RBRACE function
    (29) function -> FUNCTION tipoFunc nomFunc LPAREN . param RPAREN LBRACE vars bloqueAux RBRACE function
    (30) param -> . tipo ID
    (31) param -> . tipo ID COMA param
    (13) tipo -> . INT
    (14) tipo -> . FLOAT
    (15) tipo -> . CHAR

    RPAREN          shift and go to state 55
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    CHAR            shift and go to state 12

    tipo                           shift and go to state 57
    param                          shift and go to state 56

state 48

    (6) main -> nomMain LPAREN RPAREN LBRACE vars bloqueAux . RBRACE

    RBRACE          shift and go to state 58


state 49

    (45) escritura -> PRINT LPAREN . escrituraAux RPAREN SEMICOLON
    (46) escrituraAux -> . expresion
    (47) escrituraAux -> . CTE_STRING
    (48) escrituraAux -> . expresion COMA escrituraAux
    (49) escrituraAux -> . CTE_STRING COMA escrituraAux
    (50) expresion -> . exp
    (51) expresion -> . exp LOWERTHAN push_poper exp
    (52) expresion -> . exp MORETHAN push_poper exp
    (53) expresion -> . exp DIFFERENT push_poper exp
    (54) exp -> . termino
    (55) exp -> . termino PLUS push_poper exp
    (56) exp -> . termino MINUS push_poper exp
    (58) termino -> . factor
    (59) termino -> . factor TIMES push_poper termino
    (60) termino -> . factor DIVIDE push_poper termino
    (61) factor -> . LPAREN expresion RPAREN
    (62) factor -> . factorAux
    (63) factorAux -> . PLUS push_poper var_cte
    (64) factorAux -> . MINUS push_poper var_cte
    (65) factorAux -> . var_cte
    (69) var_cte -> . ID push_id
    (70) var_cte -> . CTE_I push_cte
    (71) var_cte -> . CTE_F push_cte

    CTE_STRING      shift and go to state 65
    LPAREN          shift and go to state 68
    PLUS            shift and go to state 62
    MINUS           shift and go to state 61
    ID              shift and go to state 69
    CTE_I           shift and go to state 67
    CTE_F           shift and go to state 64

    escrituraAux                   shift and go to state 70
    expresion                      shift and go to state 66
    var_cte                        shift and go to state 59
    termino                        shift and go to state 60
    exp                            shift and go to state 71
    factor                         shift and go to state 63
    factorAux                      shift and go to state 72

state 50

    (34) bloqueAux -> estatuto bloqueAux .

    RBRACE          reduce using rule 34 (bloqueAux -> estatuto bloqueAux .)


state 51

    (41) asignacion -> ID push_id . EQUAL push_poper expresion SEMICOLON
    (42) comparacion -> ID push_id . DOUBLEEQUAL push_poper expresion SEMICOLON

    EQUAL           shift and go to state 74
    DOUBLEEQUAL     shift and go to state 73


state 52

    (43) condicion -> IF LPAREN . expresion RPAREN bloque SEMICOLON
    (44) condicion -> IF LPAREN . expresion RPAREN bloque ELSE bloque SEMICOLON
    (50) expresion -> . exp
    (51) expresion -> . exp LOWERTHAN push_poper exp
    (52) expresion -> . exp MORETHAN push_poper exp
    (53) expresion -> . exp DIFFERENT push_poper exp
    (54) exp -> . termino
    (55) exp -> . termino PLUS push_poper exp
    (56) exp -> . termino MINUS push_poper exp
    (58) termino -> . factor
    (59) termino -> . factor TIMES push_poper termino
    (60) termino -> . factor DIVIDE push_poper termino
    (61) factor -> . LPAREN expresion RPAREN
    (62) factor -> . factorAux
    (63) factorAux -> . PLUS push_poper var_cte
    (64) factorAux -> . MINUS push_poper var_cte
    (65) factorAux -> . var_cte
    (69) var_cte -> . ID push_id
    (70) var_cte -> . CTE_I push_cte
    (71) var_cte -> . CTE_F push_cte

    LPAREN          shift and go to state 68
    PLUS            shift and go to state 62
    MINUS           shift and go to state 61
    ID              shift and go to state 69
    CTE_I           shift and go to state 67
    CTE_F           shift and go to state 64

    expresion                      shift and go to state 75
    var_cte                        shift and go to state 59
    termino                        shift and go to state 60
    exp                            shift and go to state 71
    factor                         shift and go to state 63
    factorAux                      shift and go to state 72

state 53

    (35) while -> WHILE LPAREN . expresion RPAREN bloque
    (50) expresion -> . exp
    (51) expresion -> . exp LOWERTHAN push_poper exp
    (52) expresion -> . exp MORETHAN push_poper exp
    (53) expresion -> . exp DIFFERENT push_poper exp
    (54) exp -> . termino
    (55) exp -> . termino PLUS push_poper exp
    (56) exp -> . termino MINUS push_poper exp
    (58) termino -> . factor
    (59) termino -> . factor TIMES push_poper termino
    (60) termino -> . factor DIVIDE push_poper termino
    (61) factor -> . LPAREN expresion RPAREN
    (62) factor -> . factorAux
    (63) factorAux -> . PLUS push_poper var_cte
    (64) factorAux -> . MINUS push_poper var_cte
    (65) factorAux -> . var_cte
    (69) var_cte -> . ID push_id
    (70) var_cte -> . CTE_I push_cte
    (71) var_cte -> . CTE_F push_cte

    LPAREN          shift and go to state 68
    PLUS            shift and go to state 62
    MINUS           shift and go to state 61
    ID              shift and go to state 69
    CTE_I           shift and go to state 67
    CTE_F           shift and go to state 64

    expresion                      shift and go to state 76
    var_cte                        shift and go to state 59
    termino                        shift and go to state 60
    exp                            shift and go to state 71
    factor                         shift and go to state 63
    factorAux                      shift and go to state 72

state 54

    (5) main -> nomMain LPAREN RPAREN LBRACE bloqueAux RBRACE .

    FUNCTION        reduce using rule 5 (main -> nomMain LPAREN RPAREN LBRACE bloqueAux RBRACE .)
    $end            reduce using rule 5 (main -> nomMain LPAREN RPAREN LBRACE bloqueAux RBRACE .)


state 55

    (22) function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN . LBRACE RBRACE
    (23) function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN . LBRACE vars bloqueAux RBRACE
    (24) function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN . LBRACE RBRACE function
    (25) function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN . LBRACE vars bloqueAux RBRACE function

    LBRACE          shift and go to state 77


state 56

    (26) function -> FUNCTION tipoFunc nomFunc LPAREN param . RPAREN LBRACE RBRACE
    (27) function -> FUNCTION tipoFunc nomFunc LPAREN param . RPAREN LBRACE vars bloqueAux RBRACE
    (28) function -> FUNCTION tipoFunc nomFunc LPAREN param . RPAREN LBRACE RBRACE function
    (29) function -> FUNCTION tipoFunc nomFunc LPAREN param . RPAREN LBRACE vars bloqueAux RBRACE function

    RPAREN          shift and go to state 78


state 57

    (30) param -> tipo . ID
    (31) param -> tipo . ID COMA param

    ID              shift and go to state 79


state 58

    (6) main -> nomMain LPAREN RPAREN LBRACE vars bloqueAux RBRACE .

    FUNCTION        reduce using rule 6 (main -> nomMain LPAREN RPAREN LBRACE vars bloqueAux RBRACE .)
    $end            reduce using rule 6 (main -> nomMain LPAREN RPAREN LBRACE vars bloqueAux RBRACE .)


state 59

    (65) factorAux -> var_cte .

    TIMES           reduce using rule 65 (factorAux -> var_cte .)
    DIVIDE          reduce using rule 65 (factorAux -> var_cte .)
    PLUS            reduce using rule 65 (factorAux -> var_cte .)
    MINUS           reduce using rule 65 (factorAux -> var_cte .)
    LOWERTHAN       reduce using rule 65 (factorAux -> var_cte .)
    MORETHAN        reduce using rule 65 (factorAux -> var_cte .)
    DIFFERENT       reduce using rule 65 (factorAux -> var_cte .)
    RPAREN          reduce using rule 65 (factorAux -> var_cte .)
    COMA            reduce using rule 65 (factorAux -> var_cte .)
    SEMICOLON       reduce using rule 65 (factorAux -> var_cte .)


state 60

    (54) exp -> termino .
    (55) exp -> termino . PLUS push_poper exp
    (56) exp -> termino . MINUS push_poper exp

    LOWERTHAN       reduce using rule 54 (exp -> termino .)
    MORETHAN        reduce using rule 54 (exp -> termino .)
    DIFFERENT       reduce using rule 54 (exp -> termino .)
    RPAREN          reduce using rule 54 (exp -> termino .)
    COMA            reduce using rule 54 (exp -> termino .)
    SEMICOLON       reduce using rule 54 (exp -> termino .)
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81


state 61

    (64) factorAux -> MINUS . push_poper var_cte
    (68) push_poper -> .

    ID              reduce using rule 68 (push_poper -> .)
    CTE_I           reduce using rule 68 (push_poper -> .)
    CTE_F           reduce using rule 68 (push_poper -> .)

    push_poper                     shift and go to state 82

state 62

    (63) factorAux -> PLUS . push_poper var_cte
    (68) push_poper -> .

    ID              reduce using rule 68 (push_poper -> .)
    CTE_I           reduce using rule 68 (push_poper -> .)
    CTE_F           reduce using rule 68 (push_poper -> .)

    push_poper                     shift and go to state 83

state 63

    (58) termino -> factor .
    (59) termino -> factor . TIMES push_poper termino
    (60) termino -> factor . DIVIDE push_poper termino

    PLUS            reduce using rule 58 (termino -> factor .)
    MINUS           reduce using rule 58 (termino -> factor .)
    LOWERTHAN       reduce using rule 58 (termino -> factor .)
    MORETHAN        reduce using rule 58 (termino -> factor .)
    DIFFERENT       reduce using rule 58 (termino -> factor .)
    COMA            reduce using rule 58 (termino -> factor .)
    RPAREN          reduce using rule 58 (termino -> factor .)
    SEMICOLON       reduce using rule 58 (termino -> factor .)
    TIMES           shift and go to state 85
    DIVIDE          shift and go to state 84


state 64

    (71) var_cte -> CTE_F . push_cte
    (67) push_cte -> .

    TIMES           reduce using rule 67 (push_cte -> .)
    DIVIDE          reduce using rule 67 (push_cte -> .)
    PLUS            reduce using rule 67 (push_cte -> .)
    MINUS           reduce using rule 67 (push_cte -> .)
    LOWERTHAN       reduce using rule 67 (push_cte -> .)
    MORETHAN        reduce using rule 67 (push_cte -> .)
    DIFFERENT       reduce using rule 67 (push_cte -> .)
    COMA            reduce using rule 67 (push_cte -> .)
    RPAREN          reduce using rule 67 (push_cte -> .)
    SEMICOLON       reduce using rule 67 (push_cte -> .)

    push_cte                       shift and go to state 86

state 65

    (47) escrituraAux -> CTE_STRING .
    (49) escrituraAux -> CTE_STRING . COMA escrituraAux

    RPAREN          reduce using rule 47 (escrituraAux -> CTE_STRING .)
    COMA            shift and go to state 87


state 66

    (46) escrituraAux -> expresion .
    (48) escrituraAux -> expresion . COMA escrituraAux

    RPAREN          reduce using rule 46 (escrituraAux -> expresion .)
    COMA            shift and go to state 88


state 67

    (70) var_cte -> CTE_I . push_cte
    (67) push_cte -> .

    TIMES           reduce using rule 67 (push_cte -> .)
    DIVIDE          reduce using rule 67 (push_cte -> .)
    PLUS            reduce using rule 67 (push_cte -> .)
    MINUS           reduce using rule 67 (push_cte -> .)
    LOWERTHAN       reduce using rule 67 (push_cte -> .)
    MORETHAN        reduce using rule 67 (push_cte -> .)
    DIFFERENT       reduce using rule 67 (push_cte -> .)
    COMA            reduce using rule 67 (push_cte -> .)
    RPAREN          reduce using rule 67 (push_cte -> .)
    SEMICOLON       reduce using rule 67 (push_cte -> .)

    push_cte                       shift and go to state 89

state 68

    (61) factor -> LPAREN . expresion RPAREN
    (50) expresion -> . exp
    (51) expresion -> . exp LOWERTHAN push_poper exp
    (52) expresion -> . exp MORETHAN push_poper exp
    (53) expresion -> . exp DIFFERENT push_poper exp
    (54) exp -> . termino
    (55) exp -> . termino PLUS push_poper exp
    (56) exp -> . termino MINUS push_poper exp
    (58) termino -> . factor
    (59) termino -> . factor TIMES push_poper termino
    (60) termino -> . factor DIVIDE push_poper termino
    (61) factor -> . LPAREN expresion RPAREN
    (62) factor -> . factorAux
    (63) factorAux -> . PLUS push_poper var_cte
    (64) factorAux -> . MINUS push_poper var_cte
    (65) factorAux -> . var_cte
    (69) var_cte -> . ID push_id
    (70) var_cte -> . CTE_I push_cte
    (71) var_cte -> . CTE_F push_cte

    LPAREN          shift and go to state 68
    PLUS            shift and go to state 62
    MINUS           shift and go to state 61
    ID              shift and go to state 69
    CTE_I           shift and go to state 67
    CTE_F           shift and go to state 64

    expresion                      shift and go to state 90
    var_cte                        shift and go to state 59
    termino                        shift and go to state 60
    exp                            shift and go to state 71
    factor                         shift and go to state 63
    factorAux                      shift and go to state 72

state 69

    (69) var_cte -> ID . push_id
    (66) push_id -> .

    TIMES           reduce using rule 66 (push_id -> .)
    DIVIDE          reduce using rule 66 (push_id -> .)
    PLUS            reduce using rule 66 (push_id -> .)
    MINUS           reduce using rule 66 (push_id -> .)
    LOWERTHAN       reduce using rule 66 (push_id -> .)
    MORETHAN        reduce using rule 66 (push_id -> .)
    DIFFERENT       reduce using rule 66 (push_id -> .)
    COMA            reduce using rule 66 (push_id -> .)
    RPAREN          reduce using rule 66 (push_id -> .)
    SEMICOLON       reduce using rule 66 (push_id -> .)

    push_id                        shift and go to state 91

state 70

    (45) escritura -> PRINT LPAREN escrituraAux . RPAREN SEMICOLON

    RPAREN          shift and go to state 92


state 71

    (50) expresion -> exp .
    (51) expresion -> exp . LOWERTHAN push_poper exp
    (52) expresion -> exp . MORETHAN push_poper exp
    (53) expresion -> exp . DIFFERENT push_poper exp

    RPAREN          reduce using rule 50 (expresion -> exp .)
    SEMICOLON       reduce using rule 50 (expresion -> exp .)
    COMA            reduce using rule 50 (expresion -> exp .)
    LOWERTHAN       shift and go to state 95
    MORETHAN        shift and go to state 93
    DIFFERENT       shift and go to state 94


state 72

    (62) factor -> factorAux .

    TIMES           reduce using rule 62 (factor -> factorAux .)
    DIVIDE          reduce using rule 62 (factor -> factorAux .)
    PLUS            reduce using rule 62 (factor -> factorAux .)
    MINUS           reduce using rule 62 (factor -> factorAux .)
    LOWERTHAN       reduce using rule 62 (factor -> factorAux .)
    MORETHAN        reduce using rule 62 (factor -> factorAux .)
    DIFFERENT       reduce using rule 62 (factor -> factorAux .)
    COMA            reduce using rule 62 (factor -> factorAux .)
    RPAREN          reduce using rule 62 (factor -> factorAux .)
    SEMICOLON       reduce using rule 62 (factor -> factorAux .)


state 73

    (42) comparacion -> ID push_id DOUBLEEQUAL . push_poper expresion SEMICOLON
    (68) push_poper -> .

    LPAREN          reduce using rule 68 (push_poper -> .)
    PLUS            reduce using rule 68 (push_poper -> .)
    MINUS           reduce using rule 68 (push_poper -> .)
    ID              reduce using rule 68 (push_poper -> .)
    CTE_I           reduce using rule 68 (push_poper -> .)
    CTE_F           reduce using rule 68 (push_poper -> .)

    push_poper                     shift and go to state 96

state 74

    (41) asignacion -> ID push_id EQUAL . push_poper expresion SEMICOLON
    (68) push_poper -> .

    LPAREN          reduce using rule 68 (push_poper -> .)
    PLUS            reduce using rule 68 (push_poper -> .)
    MINUS           reduce using rule 68 (push_poper -> .)
    ID              reduce using rule 68 (push_poper -> .)
    CTE_I           reduce using rule 68 (push_poper -> .)
    CTE_F           reduce using rule 68 (push_poper -> .)

    push_poper                     shift and go to state 97

state 75

    (43) condicion -> IF LPAREN expresion . RPAREN bloque SEMICOLON
    (44) condicion -> IF LPAREN expresion . RPAREN bloque ELSE bloque SEMICOLON

    RPAREN          shift and go to state 98


state 76

    (35) while -> WHILE LPAREN expresion . RPAREN bloque

    RPAREN          shift and go to state 99


state 77

    (22) function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE . RBRACE
    (23) function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE . vars bloqueAux RBRACE
    (24) function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE . RBRACE function
    (25) function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE . vars bloqueAux RBRACE function
    (8) vars -> . VAR varAux1

    RBRACE          shift and go to state 100
    VAR             shift and go to state 8

    vars                           shift and go to state 101

state 78

    (26) function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN . LBRACE RBRACE
    (27) function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN . LBRACE vars bloqueAux RBRACE
    (28) function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN . LBRACE RBRACE function
    (29) function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN . LBRACE vars bloqueAux RBRACE function

    LBRACE          shift and go to state 102


state 79

    (30) param -> tipo ID .
    (31) param -> tipo ID . COMA param

    RPAREN          reduce using rule 30 (param -> tipo ID .)
    COMA            shift and go to state 103


state 80

    (55) exp -> termino PLUS . push_poper exp
    (68) push_poper -> .

    LPAREN          reduce using rule 68 (push_poper -> .)
    PLUS            reduce using rule 68 (push_poper -> .)
    MINUS           reduce using rule 68 (push_poper -> .)
    ID              reduce using rule 68 (push_poper -> .)
    CTE_I           reduce using rule 68 (push_poper -> .)
    CTE_F           reduce using rule 68 (push_poper -> .)

    push_poper                     shift and go to state 104

state 81

    (56) exp -> termino MINUS . push_poper exp
    (68) push_poper -> .

    LPAREN          reduce using rule 68 (push_poper -> .)
    PLUS            reduce using rule 68 (push_poper -> .)
    MINUS           reduce using rule 68 (push_poper -> .)
    ID              reduce using rule 68 (push_poper -> .)
    CTE_I           reduce using rule 68 (push_poper -> .)
    CTE_F           reduce using rule 68 (push_poper -> .)

    push_poper                     shift and go to state 105

state 82

    (64) factorAux -> MINUS push_poper . var_cte
    (69) var_cte -> . ID push_id
    (70) var_cte -> . CTE_I push_cte
    (71) var_cte -> . CTE_F push_cte

    ID              shift and go to state 69
    CTE_I           shift and go to state 67
    CTE_F           shift and go to state 64

    var_cte                        shift and go to state 106

state 83

    (63) factorAux -> PLUS push_poper . var_cte
    (69) var_cte -> . ID push_id
    (70) var_cte -> . CTE_I push_cte
    (71) var_cte -> . CTE_F push_cte

    ID              shift and go to state 69
    CTE_I           shift and go to state 67
    CTE_F           shift and go to state 64

    var_cte                        shift and go to state 107

state 84

    (60) termino -> factor DIVIDE . push_poper termino
    (68) push_poper -> .

    LPAREN          reduce using rule 68 (push_poper -> .)
    PLUS            reduce using rule 68 (push_poper -> .)
    MINUS           reduce using rule 68 (push_poper -> .)
    ID              reduce using rule 68 (push_poper -> .)
    CTE_I           reduce using rule 68 (push_poper -> .)
    CTE_F           reduce using rule 68 (push_poper -> .)

    push_poper                     shift and go to state 108

state 85

    (59) termino -> factor TIMES . push_poper termino
    (68) push_poper -> .

    LPAREN          reduce using rule 68 (push_poper -> .)
    PLUS            reduce using rule 68 (push_poper -> .)
    MINUS           reduce using rule 68 (push_poper -> .)
    ID              reduce using rule 68 (push_poper -> .)
    CTE_I           reduce using rule 68 (push_poper -> .)
    CTE_F           reduce using rule 68 (push_poper -> .)

    push_poper                     shift and go to state 109

state 86

    (71) var_cte -> CTE_F push_cte .

    TIMES           reduce using rule 71 (var_cte -> CTE_F push_cte .)
    DIVIDE          reduce using rule 71 (var_cte -> CTE_F push_cte .)
    PLUS            reduce using rule 71 (var_cte -> CTE_F push_cte .)
    MINUS           reduce using rule 71 (var_cte -> CTE_F push_cte .)
    LOWERTHAN       reduce using rule 71 (var_cte -> CTE_F push_cte .)
    MORETHAN        reduce using rule 71 (var_cte -> CTE_F push_cte .)
    DIFFERENT       reduce using rule 71 (var_cte -> CTE_F push_cte .)
    COMA            reduce using rule 71 (var_cte -> CTE_F push_cte .)
    RPAREN          reduce using rule 71 (var_cte -> CTE_F push_cte .)
    SEMICOLON       reduce using rule 71 (var_cte -> CTE_F push_cte .)


state 87

    (49) escrituraAux -> CTE_STRING COMA . escrituraAux
    (46) escrituraAux -> . expresion
    (47) escrituraAux -> . CTE_STRING
    (48) escrituraAux -> . expresion COMA escrituraAux
    (49) escrituraAux -> . CTE_STRING COMA escrituraAux
    (50) expresion -> . exp
    (51) expresion -> . exp LOWERTHAN push_poper exp
    (52) expresion -> . exp MORETHAN push_poper exp
    (53) expresion -> . exp DIFFERENT push_poper exp
    (54) exp -> . termino
    (55) exp -> . termino PLUS push_poper exp
    (56) exp -> . termino MINUS push_poper exp
    (58) termino -> . factor
    (59) termino -> . factor TIMES push_poper termino
    (60) termino -> . factor DIVIDE push_poper termino
    (61) factor -> . LPAREN expresion RPAREN
    (62) factor -> . factorAux
    (63) factorAux -> . PLUS push_poper var_cte
    (64) factorAux -> . MINUS push_poper var_cte
    (65) factorAux -> . var_cte
    (69) var_cte -> . ID push_id
    (70) var_cte -> . CTE_I push_cte
    (71) var_cte -> . CTE_F push_cte

    CTE_STRING      shift and go to state 65
    LPAREN          shift and go to state 68
    PLUS            shift and go to state 62
    MINUS           shift and go to state 61
    ID              shift and go to state 69
    CTE_I           shift and go to state 67
    CTE_F           shift and go to state 64

    escrituraAux                   shift and go to state 110
    expresion                      shift and go to state 66
    var_cte                        shift and go to state 59
    termino                        shift and go to state 60
    exp                            shift and go to state 71
    factor                         shift and go to state 63
    factorAux                      shift and go to state 72

state 88

    (48) escrituraAux -> expresion COMA . escrituraAux
    (46) escrituraAux -> . expresion
    (47) escrituraAux -> . CTE_STRING
    (48) escrituraAux -> . expresion COMA escrituraAux
    (49) escrituraAux -> . CTE_STRING COMA escrituraAux
    (50) expresion -> . exp
    (51) expresion -> . exp LOWERTHAN push_poper exp
    (52) expresion -> . exp MORETHAN push_poper exp
    (53) expresion -> . exp DIFFERENT push_poper exp
    (54) exp -> . termino
    (55) exp -> . termino PLUS push_poper exp
    (56) exp -> . termino MINUS push_poper exp
    (58) termino -> . factor
    (59) termino -> . factor TIMES push_poper termino
    (60) termino -> . factor DIVIDE push_poper termino
    (61) factor -> . LPAREN expresion RPAREN
    (62) factor -> . factorAux
    (63) factorAux -> . PLUS push_poper var_cte
    (64) factorAux -> . MINUS push_poper var_cte
    (65) factorAux -> . var_cte
    (69) var_cte -> . ID push_id
    (70) var_cte -> . CTE_I push_cte
    (71) var_cte -> . CTE_F push_cte

    CTE_STRING      shift and go to state 65
    LPAREN          shift and go to state 68
    PLUS            shift and go to state 62
    MINUS           shift and go to state 61
    ID              shift and go to state 69
    CTE_I           shift and go to state 67
    CTE_F           shift and go to state 64

    expresion                      shift and go to state 66
    escrituraAux                   shift and go to state 111
    var_cte                        shift and go to state 59
    termino                        shift and go to state 60
    exp                            shift and go to state 71
    factor                         shift and go to state 63
    factorAux                      shift and go to state 72

state 89

    (70) var_cte -> CTE_I push_cte .

    TIMES           reduce using rule 70 (var_cte -> CTE_I push_cte .)
    DIVIDE          reduce using rule 70 (var_cte -> CTE_I push_cte .)
    PLUS            reduce using rule 70 (var_cte -> CTE_I push_cte .)
    MINUS           reduce using rule 70 (var_cte -> CTE_I push_cte .)
    LOWERTHAN       reduce using rule 70 (var_cte -> CTE_I push_cte .)
    MORETHAN        reduce using rule 70 (var_cte -> CTE_I push_cte .)
    DIFFERENT       reduce using rule 70 (var_cte -> CTE_I push_cte .)
    COMA            reduce using rule 70 (var_cte -> CTE_I push_cte .)
    RPAREN          reduce using rule 70 (var_cte -> CTE_I push_cte .)
    SEMICOLON       reduce using rule 70 (var_cte -> CTE_I push_cte .)


state 90

    (61) factor -> LPAREN expresion . RPAREN

    RPAREN          shift and go to state 112


state 91

    (69) var_cte -> ID push_id .

    TIMES           reduce using rule 69 (var_cte -> ID push_id .)
    DIVIDE          reduce using rule 69 (var_cte -> ID push_id .)
    PLUS            reduce using rule 69 (var_cte -> ID push_id .)
    MINUS           reduce using rule 69 (var_cte -> ID push_id .)
    LOWERTHAN       reduce using rule 69 (var_cte -> ID push_id .)
    MORETHAN        reduce using rule 69 (var_cte -> ID push_id .)
    DIFFERENT       reduce using rule 69 (var_cte -> ID push_id .)
    COMA            reduce using rule 69 (var_cte -> ID push_id .)
    RPAREN          reduce using rule 69 (var_cte -> ID push_id .)
    SEMICOLON       reduce using rule 69 (var_cte -> ID push_id .)


state 92

    (45) escritura -> PRINT LPAREN escrituraAux RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 113


state 93

    (52) expresion -> exp MORETHAN . push_poper exp
    (68) push_poper -> .

    LPAREN          reduce using rule 68 (push_poper -> .)
    PLUS            reduce using rule 68 (push_poper -> .)
    MINUS           reduce using rule 68 (push_poper -> .)
    ID              reduce using rule 68 (push_poper -> .)
    CTE_I           reduce using rule 68 (push_poper -> .)
    CTE_F           reduce using rule 68 (push_poper -> .)

    push_poper                     shift and go to state 114

state 94

    (53) expresion -> exp DIFFERENT . push_poper exp
    (68) push_poper -> .

    LPAREN          reduce using rule 68 (push_poper -> .)
    PLUS            reduce using rule 68 (push_poper -> .)
    MINUS           reduce using rule 68 (push_poper -> .)
    ID              reduce using rule 68 (push_poper -> .)
    CTE_I           reduce using rule 68 (push_poper -> .)
    CTE_F           reduce using rule 68 (push_poper -> .)

    push_poper                     shift and go to state 115

state 95

    (51) expresion -> exp LOWERTHAN . push_poper exp
    (68) push_poper -> .

    LPAREN          reduce using rule 68 (push_poper -> .)
    PLUS            reduce using rule 68 (push_poper -> .)
    MINUS           reduce using rule 68 (push_poper -> .)
    ID              reduce using rule 68 (push_poper -> .)
    CTE_I           reduce using rule 68 (push_poper -> .)
    CTE_F           reduce using rule 68 (push_poper -> .)

    push_poper                     shift and go to state 116

state 96

    (42) comparacion -> ID push_id DOUBLEEQUAL push_poper . expresion SEMICOLON
    (50) expresion -> . exp
    (51) expresion -> . exp LOWERTHAN push_poper exp
    (52) expresion -> . exp MORETHAN push_poper exp
    (53) expresion -> . exp DIFFERENT push_poper exp
    (54) exp -> . termino
    (55) exp -> . termino PLUS push_poper exp
    (56) exp -> . termino MINUS push_poper exp
    (58) termino -> . factor
    (59) termino -> . factor TIMES push_poper termino
    (60) termino -> . factor DIVIDE push_poper termino
    (61) factor -> . LPAREN expresion RPAREN
    (62) factor -> . factorAux
    (63) factorAux -> . PLUS push_poper var_cte
    (64) factorAux -> . MINUS push_poper var_cte
    (65) factorAux -> . var_cte
    (69) var_cte -> . ID push_id
    (70) var_cte -> . CTE_I push_cte
    (71) var_cte -> . CTE_F push_cte

    LPAREN          shift and go to state 68
    PLUS            shift and go to state 62
    MINUS           shift and go to state 61
    ID              shift and go to state 69
    CTE_I           shift and go to state 67
    CTE_F           shift and go to state 64

    expresion                      shift and go to state 117
    var_cte                        shift and go to state 59
    termino                        shift and go to state 60
    exp                            shift and go to state 71
    factor                         shift and go to state 63
    factorAux                      shift and go to state 72

state 97

    (41) asignacion -> ID push_id EQUAL push_poper . expresion SEMICOLON
    (50) expresion -> . exp
    (51) expresion -> . exp LOWERTHAN push_poper exp
    (52) expresion -> . exp MORETHAN push_poper exp
    (53) expresion -> . exp DIFFERENT push_poper exp
    (54) exp -> . termino
    (55) exp -> . termino PLUS push_poper exp
    (56) exp -> . termino MINUS push_poper exp
    (58) termino -> . factor
    (59) termino -> . factor TIMES push_poper termino
    (60) termino -> . factor DIVIDE push_poper termino
    (61) factor -> . LPAREN expresion RPAREN
    (62) factor -> . factorAux
    (63) factorAux -> . PLUS push_poper var_cte
    (64) factorAux -> . MINUS push_poper var_cte
    (65) factorAux -> . var_cte
    (69) var_cte -> . ID push_id
    (70) var_cte -> . CTE_I push_cte
    (71) var_cte -> . CTE_F push_cte

    LPAREN          shift and go to state 68
    PLUS            shift and go to state 62
    MINUS           shift and go to state 61
    ID              shift and go to state 69
    CTE_I           shift and go to state 67
    CTE_F           shift and go to state 64

    expresion                      shift and go to state 118
    var_cte                        shift and go to state 59
    termino                        shift and go to state 60
    exp                            shift and go to state 71
    factor                         shift and go to state 63
    factorAux                      shift and go to state 72

state 98

    (43) condicion -> IF LPAREN expresion RPAREN . bloque SEMICOLON
    (44) condicion -> IF LPAREN expresion RPAREN . bloque ELSE bloque SEMICOLON
    (20) bloque -> . LBRACE RBRACE
    (21) bloque -> . LBRACE bloqueAux RBRACE

    LBRACE          shift and go to state 119

    bloque                         shift and go to state 120

state 99

    (35) while -> WHILE LPAREN expresion RPAREN . bloque
    (20) bloque -> . LBRACE RBRACE
    (21) bloque -> . LBRACE bloqueAux RBRACE

    LBRACE          shift and go to state 119

    bloque                         shift and go to state 121

state 100

    (22) function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE .
    (24) function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE . function
    (22) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE
    (23) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE
    (24) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE function
    (25) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE function
    (26) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE
    (27) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE
    (28) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE function
    (29) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE function

    $end            reduce using rule 22 (function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE .)
    FUNCTION        shift and go to state 18

    function                       shift and go to state 122

state 101

    (23) function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars . bloqueAux RBRACE
    (25) function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars . bloqueAux RBRACE function
    (33) bloqueAux -> . estatuto
    (34) bloqueAux -> . estatuto bloqueAux
    (36) estatuto -> . asignacion
    (37) estatuto -> . condicion
    (38) estatuto -> . escritura
    (39) estatuto -> . while
    (40) estatuto -> . comparacion
    (41) asignacion -> . ID push_id EQUAL push_poper expresion SEMICOLON
    (43) condicion -> . IF LPAREN expresion RPAREN bloque SEMICOLON
    (44) condicion -> . IF LPAREN expresion RPAREN bloque ELSE bloque SEMICOLON
    (45) escritura -> . PRINT LPAREN escrituraAux RPAREN SEMICOLON
    (35) while -> . WHILE LPAREN expresion RPAREN bloque
    (42) comparacion -> . ID push_id DOUBLEEQUAL push_poper expresion SEMICOLON

    ID              shift and go to state 37
    IF              shift and go to state 38
    PRINT           shift and go to state 34
    WHILE           shift and go to state 40

    asignacion                     shift and go to state 39
    estatuto                       shift and go to state 35
    bloqueAux                      shift and go to state 123
    while                          shift and go to state 42
    condicion                      shift and go to state 36
    comparacion                    shift and go to state 43
    escritura                      shift and go to state 44

state 102

    (26) function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE . RBRACE
    (27) function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE . vars bloqueAux RBRACE
    (28) function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE . RBRACE function
    (29) function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE . vars bloqueAux RBRACE function
    (8) vars -> . VAR varAux1

    RBRACE          shift and go to state 124
    VAR             shift and go to state 8

    vars                           shift and go to state 125

state 103

    (31) param -> tipo ID COMA . param
    (30) param -> . tipo ID
    (31) param -> . tipo ID COMA param
    (13) tipo -> . INT
    (14) tipo -> . FLOAT
    (15) tipo -> . CHAR

    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    CHAR            shift and go to state 12

    param                          shift and go to state 126
    tipo                           shift and go to state 57

state 104

    (55) exp -> termino PLUS push_poper . exp
    (54) exp -> . termino
    (55) exp -> . termino PLUS push_poper exp
    (56) exp -> . termino MINUS push_poper exp
    (58) termino -> . factor
    (59) termino -> . factor TIMES push_poper termino
    (60) termino -> . factor DIVIDE push_poper termino
    (61) factor -> . LPAREN expresion RPAREN
    (62) factor -> . factorAux
    (63) factorAux -> . PLUS push_poper var_cte
    (64) factorAux -> . MINUS push_poper var_cte
    (65) factorAux -> . var_cte
    (69) var_cte -> . ID push_id
    (70) var_cte -> . CTE_I push_cte
    (71) var_cte -> . CTE_F push_cte

    LPAREN          shift and go to state 68
    PLUS            shift and go to state 62
    MINUS           shift and go to state 61
    ID              shift and go to state 69
    CTE_I           shift and go to state 67
    CTE_F           shift and go to state 64

    var_cte                        shift and go to state 59
    termino                        shift and go to state 60
    exp                            shift and go to state 127
    factor                         shift and go to state 63
    factorAux                      shift and go to state 72

state 105

    (56) exp -> termino MINUS push_poper . exp
    (54) exp -> . termino
    (55) exp -> . termino PLUS push_poper exp
    (56) exp -> . termino MINUS push_poper exp
    (58) termino -> . factor
    (59) termino -> . factor TIMES push_poper termino
    (60) termino -> . factor DIVIDE push_poper termino
    (61) factor -> . LPAREN expresion RPAREN
    (62) factor -> . factorAux
    (63) factorAux -> . PLUS push_poper var_cte
    (64) factorAux -> . MINUS push_poper var_cte
    (65) factorAux -> . var_cte
    (69) var_cte -> . ID push_id
    (70) var_cte -> . CTE_I push_cte
    (71) var_cte -> . CTE_F push_cte

    LPAREN          shift and go to state 68
    PLUS            shift and go to state 62
    MINUS           shift and go to state 61
    ID              shift and go to state 69
    CTE_I           shift and go to state 67
    CTE_F           shift and go to state 64

    var_cte                        shift and go to state 59
    termino                        shift and go to state 60
    exp                            shift and go to state 128
    factor                         shift and go to state 63
    factorAux                      shift and go to state 72

state 106

    (64) factorAux -> MINUS push_poper var_cte .

    TIMES           reduce using rule 64 (factorAux -> MINUS push_poper var_cte .)
    DIVIDE          reduce using rule 64 (factorAux -> MINUS push_poper var_cte .)
    PLUS            reduce using rule 64 (factorAux -> MINUS push_poper var_cte .)
    MINUS           reduce using rule 64 (factorAux -> MINUS push_poper var_cte .)
    LOWERTHAN       reduce using rule 64 (factorAux -> MINUS push_poper var_cte .)
    MORETHAN        reduce using rule 64 (factorAux -> MINUS push_poper var_cte .)
    DIFFERENT       reduce using rule 64 (factorAux -> MINUS push_poper var_cte .)
    RPAREN          reduce using rule 64 (factorAux -> MINUS push_poper var_cte .)
    COMA            reduce using rule 64 (factorAux -> MINUS push_poper var_cte .)
    SEMICOLON       reduce using rule 64 (factorAux -> MINUS push_poper var_cte .)


state 107

    (63) factorAux -> PLUS push_poper var_cte .

    TIMES           reduce using rule 63 (factorAux -> PLUS push_poper var_cte .)
    DIVIDE          reduce using rule 63 (factorAux -> PLUS push_poper var_cte .)
    PLUS            reduce using rule 63 (factorAux -> PLUS push_poper var_cte .)
    MINUS           reduce using rule 63 (factorAux -> PLUS push_poper var_cte .)
    LOWERTHAN       reduce using rule 63 (factorAux -> PLUS push_poper var_cte .)
    MORETHAN        reduce using rule 63 (factorAux -> PLUS push_poper var_cte .)
    DIFFERENT       reduce using rule 63 (factorAux -> PLUS push_poper var_cte .)
    RPAREN          reduce using rule 63 (factorAux -> PLUS push_poper var_cte .)
    COMA            reduce using rule 63 (factorAux -> PLUS push_poper var_cte .)
    SEMICOLON       reduce using rule 63 (factorAux -> PLUS push_poper var_cte .)


state 108

    (60) termino -> factor DIVIDE push_poper . termino
    (58) termino -> . factor
    (59) termino -> . factor TIMES push_poper termino
    (60) termino -> . factor DIVIDE push_poper termino
    (61) factor -> . LPAREN expresion RPAREN
    (62) factor -> . factorAux
    (63) factorAux -> . PLUS push_poper var_cte
    (64) factorAux -> . MINUS push_poper var_cte
    (65) factorAux -> . var_cte
    (69) var_cte -> . ID push_id
    (70) var_cte -> . CTE_I push_cte
    (71) var_cte -> . CTE_F push_cte

    LPAREN          shift and go to state 68
    PLUS            shift and go to state 62
    MINUS           shift and go to state 61
    ID              shift and go to state 69
    CTE_I           shift and go to state 67
    CTE_F           shift and go to state 64

    var_cte                        shift and go to state 59
    termino                        shift and go to state 129
    factor                         shift and go to state 63
    factorAux                      shift and go to state 72

state 109

    (59) termino -> factor TIMES push_poper . termino
    (58) termino -> . factor
    (59) termino -> . factor TIMES push_poper termino
    (60) termino -> . factor DIVIDE push_poper termino
    (61) factor -> . LPAREN expresion RPAREN
    (62) factor -> . factorAux
    (63) factorAux -> . PLUS push_poper var_cte
    (64) factorAux -> . MINUS push_poper var_cte
    (65) factorAux -> . var_cte
    (69) var_cte -> . ID push_id
    (70) var_cte -> . CTE_I push_cte
    (71) var_cte -> . CTE_F push_cte

    LPAREN          shift and go to state 68
    PLUS            shift and go to state 62
    MINUS           shift and go to state 61
    ID              shift and go to state 69
    CTE_I           shift and go to state 67
    CTE_F           shift and go to state 64

    var_cte                        shift and go to state 59
    termino                        shift and go to state 130
    factor                         shift and go to state 63
    factorAux                      shift and go to state 72

state 110

    (49) escrituraAux -> CTE_STRING COMA escrituraAux .

    RPAREN          reduce using rule 49 (escrituraAux -> CTE_STRING COMA escrituraAux .)


state 111

    (48) escrituraAux -> expresion COMA escrituraAux .

    RPAREN          reduce using rule 48 (escrituraAux -> expresion COMA escrituraAux .)


state 112

    (61) factor -> LPAREN expresion RPAREN .

    TIMES           reduce using rule 61 (factor -> LPAREN expresion RPAREN .)
    DIVIDE          reduce using rule 61 (factor -> LPAREN expresion RPAREN .)
    PLUS            reduce using rule 61 (factor -> LPAREN expresion RPAREN .)
    MINUS           reduce using rule 61 (factor -> LPAREN expresion RPAREN .)
    LOWERTHAN       reduce using rule 61 (factor -> LPAREN expresion RPAREN .)
    MORETHAN        reduce using rule 61 (factor -> LPAREN expresion RPAREN .)
    DIFFERENT       reduce using rule 61 (factor -> LPAREN expresion RPAREN .)
    COMA            reduce using rule 61 (factor -> LPAREN expresion RPAREN .)
    RPAREN          reduce using rule 61 (factor -> LPAREN expresion RPAREN .)
    SEMICOLON       reduce using rule 61 (factor -> LPAREN expresion RPAREN .)


state 113

    (45) escritura -> PRINT LPAREN escrituraAux RPAREN SEMICOLON .

    ID              reduce using rule 45 (escritura -> PRINT LPAREN escrituraAux RPAREN SEMICOLON .)
    IF              reduce using rule 45 (escritura -> PRINT LPAREN escrituraAux RPAREN SEMICOLON .)
    PRINT           reduce using rule 45 (escritura -> PRINT LPAREN escrituraAux RPAREN SEMICOLON .)
    WHILE           reduce using rule 45 (escritura -> PRINT LPAREN escrituraAux RPAREN SEMICOLON .)
    RBRACE          reduce using rule 45 (escritura -> PRINT LPAREN escrituraAux RPAREN SEMICOLON .)


state 114

    (52) expresion -> exp MORETHAN push_poper . exp
    (54) exp -> . termino
    (55) exp -> . termino PLUS push_poper exp
    (56) exp -> . termino MINUS push_poper exp
    (58) termino -> . factor
    (59) termino -> . factor TIMES push_poper termino
    (60) termino -> . factor DIVIDE push_poper termino
    (61) factor -> . LPAREN expresion RPAREN
    (62) factor -> . factorAux
    (63) factorAux -> . PLUS push_poper var_cte
    (64) factorAux -> . MINUS push_poper var_cte
    (65) factorAux -> . var_cte
    (69) var_cte -> . ID push_id
    (70) var_cte -> . CTE_I push_cte
    (71) var_cte -> . CTE_F push_cte

    LPAREN          shift and go to state 68
    PLUS            shift and go to state 62
    MINUS           shift and go to state 61
    ID              shift and go to state 69
    CTE_I           shift and go to state 67
    CTE_F           shift and go to state 64

    var_cte                        shift and go to state 59
    termino                        shift and go to state 60
    exp                            shift and go to state 131
    factor                         shift and go to state 63
    factorAux                      shift and go to state 72

state 115

    (53) expresion -> exp DIFFERENT push_poper . exp
    (54) exp -> . termino
    (55) exp -> . termino PLUS push_poper exp
    (56) exp -> . termino MINUS push_poper exp
    (58) termino -> . factor
    (59) termino -> . factor TIMES push_poper termino
    (60) termino -> . factor DIVIDE push_poper termino
    (61) factor -> . LPAREN expresion RPAREN
    (62) factor -> . factorAux
    (63) factorAux -> . PLUS push_poper var_cte
    (64) factorAux -> . MINUS push_poper var_cte
    (65) factorAux -> . var_cte
    (69) var_cte -> . ID push_id
    (70) var_cte -> . CTE_I push_cte
    (71) var_cte -> . CTE_F push_cte

    LPAREN          shift and go to state 68
    PLUS            shift and go to state 62
    MINUS           shift and go to state 61
    ID              shift and go to state 69
    CTE_I           shift and go to state 67
    CTE_F           shift and go to state 64

    var_cte                        shift and go to state 59
    termino                        shift and go to state 60
    exp                            shift and go to state 132
    factor                         shift and go to state 63
    factorAux                      shift and go to state 72

state 116

    (51) expresion -> exp LOWERTHAN push_poper . exp
    (54) exp -> . termino
    (55) exp -> . termino PLUS push_poper exp
    (56) exp -> . termino MINUS push_poper exp
    (58) termino -> . factor
    (59) termino -> . factor TIMES push_poper termino
    (60) termino -> . factor DIVIDE push_poper termino
    (61) factor -> . LPAREN expresion RPAREN
    (62) factor -> . factorAux
    (63) factorAux -> . PLUS push_poper var_cte
    (64) factorAux -> . MINUS push_poper var_cte
    (65) factorAux -> . var_cte
    (69) var_cte -> . ID push_id
    (70) var_cte -> . CTE_I push_cte
    (71) var_cte -> . CTE_F push_cte

    LPAREN          shift and go to state 68
    PLUS            shift and go to state 62
    MINUS           shift and go to state 61
    ID              shift and go to state 69
    CTE_I           shift and go to state 67
    CTE_F           shift and go to state 64

    var_cte                        shift and go to state 59
    termino                        shift and go to state 60
    exp                            shift and go to state 133
    factor                         shift and go to state 63
    factorAux                      shift and go to state 72

state 117

    (42) comparacion -> ID push_id DOUBLEEQUAL push_poper expresion . SEMICOLON

    SEMICOLON       shift and go to state 134


state 118

    (41) asignacion -> ID push_id EQUAL push_poper expresion . SEMICOLON

    SEMICOLON       shift and go to state 135


state 119

    (20) bloque -> LBRACE . RBRACE
    (21) bloque -> LBRACE . bloqueAux RBRACE
    (33) bloqueAux -> . estatuto
    (34) bloqueAux -> . estatuto bloqueAux
    (36) estatuto -> . asignacion
    (37) estatuto -> . condicion
    (38) estatuto -> . escritura
    (39) estatuto -> . while
    (40) estatuto -> . comparacion
    (41) asignacion -> . ID push_id EQUAL push_poper expresion SEMICOLON
    (43) condicion -> . IF LPAREN expresion RPAREN bloque SEMICOLON
    (44) condicion -> . IF LPAREN expresion RPAREN bloque ELSE bloque SEMICOLON
    (45) escritura -> . PRINT LPAREN escrituraAux RPAREN SEMICOLON
    (35) while -> . WHILE LPAREN expresion RPAREN bloque
    (42) comparacion -> . ID push_id DOUBLEEQUAL push_poper expresion SEMICOLON

    RBRACE          shift and go to state 136
    ID              shift and go to state 37
    IF              shift and go to state 38
    PRINT           shift and go to state 34
    WHILE           shift and go to state 40

    asignacion                     shift and go to state 39
    estatuto                       shift and go to state 35
    bloqueAux                      shift and go to state 137
    while                          shift and go to state 42
    condicion                      shift and go to state 36
    comparacion                    shift and go to state 43
    escritura                      shift and go to state 44

state 120

    (43) condicion -> IF LPAREN expresion RPAREN bloque . SEMICOLON
    (44) condicion -> IF LPAREN expresion RPAREN bloque . ELSE bloque SEMICOLON

    SEMICOLON       shift and go to state 138
    ELSE            shift and go to state 139


state 121

    (35) while -> WHILE LPAREN expresion RPAREN bloque .

    ID              reduce using rule 35 (while -> WHILE LPAREN expresion RPAREN bloque .)
    IF              reduce using rule 35 (while -> WHILE LPAREN expresion RPAREN bloque .)
    PRINT           reduce using rule 35 (while -> WHILE LPAREN expresion RPAREN bloque .)
    WHILE           reduce using rule 35 (while -> WHILE LPAREN expresion RPAREN bloque .)
    RBRACE          reduce using rule 35 (while -> WHILE LPAREN expresion RPAREN bloque .)


state 122

    (24) function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE function .

    $end            reduce using rule 24 (function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE function .)


state 123

    (23) function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux . RBRACE
    (25) function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux . RBRACE function

    RBRACE          shift and go to state 140


state 124

    (26) function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE .
    (28) function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE . function
    (22) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE
    (23) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE
    (24) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE function
    (25) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE function
    (26) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE
    (27) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE
    (28) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE function
    (29) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE function

    $end            reduce using rule 26 (function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE .)
    FUNCTION        shift and go to state 18

    function                       shift and go to state 141

state 125

    (27) function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars . bloqueAux RBRACE
    (29) function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars . bloqueAux RBRACE function
    (33) bloqueAux -> . estatuto
    (34) bloqueAux -> . estatuto bloqueAux
    (36) estatuto -> . asignacion
    (37) estatuto -> . condicion
    (38) estatuto -> . escritura
    (39) estatuto -> . while
    (40) estatuto -> . comparacion
    (41) asignacion -> . ID push_id EQUAL push_poper expresion SEMICOLON
    (43) condicion -> . IF LPAREN expresion RPAREN bloque SEMICOLON
    (44) condicion -> . IF LPAREN expresion RPAREN bloque ELSE bloque SEMICOLON
    (45) escritura -> . PRINT LPAREN escrituraAux RPAREN SEMICOLON
    (35) while -> . WHILE LPAREN expresion RPAREN bloque
    (42) comparacion -> . ID push_id DOUBLEEQUAL push_poper expresion SEMICOLON

    ID              shift and go to state 37
    IF              shift and go to state 38
    PRINT           shift and go to state 34
    WHILE           shift and go to state 40

    asignacion                     shift and go to state 39
    estatuto                       shift and go to state 35
    bloqueAux                      shift and go to state 142
    while                          shift and go to state 42
    condicion                      shift and go to state 36
    comparacion                    shift and go to state 43
    escritura                      shift and go to state 44

state 126

    (31) param -> tipo ID COMA param .

    RPAREN          reduce using rule 31 (param -> tipo ID COMA param .)


state 127

    (55) exp -> termino PLUS push_poper exp .

    LOWERTHAN       reduce using rule 55 (exp -> termino PLUS push_poper exp .)
    MORETHAN        reduce using rule 55 (exp -> termino PLUS push_poper exp .)
    DIFFERENT       reduce using rule 55 (exp -> termino PLUS push_poper exp .)
    RPAREN          reduce using rule 55 (exp -> termino PLUS push_poper exp .)
    COMA            reduce using rule 55 (exp -> termino PLUS push_poper exp .)
    SEMICOLON       reduce using rule 55 (exp -> termino PLUS push_poper exp .)


state 128

    (56) exp -> termino MINUS push_poper exp .

    LOWERTHAN       reduce using rule 56 (exp -> termino MINUS push_poper exp .)
    MORETHAN        reduce using rule 56 (exp -> termino MINUS push_poper exp .)
    DIFFERENT       reduce using rule 56 (exp -> termino MINUS push_poper exp .)
    RPAREN          reduce using rule 56 (exp -> termino MINUS push_poper exp .)
    COMA            reduce using rule 56 (exp -> termino MINUS push_poper exp .)
    SEMICOLON       reduce using rule 56 (exp -> termino MINUS push_poper exp .)


state 129

    (60) termino -> factor DIVIDE push_poper termino .

    PLUS            reduce using rule 60 (termino -> factor DIVIDE push_poper termino .)
    MINUS           reduce using rule 60 (termino -> factor DIVIDE push_poper termino .)
    LOWERTHAN       reduce using rule 60 (termino -> factor DIVIDE push_poper termino .)
    MORETHAN        reduce using rule 60 (termino -> factor DIVIDE push_poper termino .)
    DIFFERENT       reduce using rule 60 (termino -> factor DIVIDE push_poper termino .)
    COMA            reduce using rule 60 (termino -> factor DIVIDE push_poper termino .)
    RPAREN          reduce using rule 60 (termino -> factor DIVIDE push_poper termino .)
    SEMICOLON       reduce using rule 60 (termino -> factor DIVIDE push_poper termino .)


state 130

    (59) termino -> factor TIMES push_poper termino .

    PLUS            reduce using rule 59 (termino -> factor TIMES push_poper termino .)
    MINUS           reduce using rule 59 (termino -> factor TIMES push_poper termino .)
    LOWERTHAN       reduce using rule 59 (termino -> factor TIMES push_poper termino .)
    MORETHAN        reduce using rule 59 (termino -> factor TIMES push_poper termino .)
    DIFFERENT       reduce using rule 59 (termino -> factor TIMES push_poper termino .)
    COMA            reduce using rule 59 (termino -> factor TIMES push_poper termino .)
    RPAREN          reduce using rule 59 (termino -> factor TIMES push_poper termino .)
    SEMICOLON       reduce using rule 59 (termino -> factor TIMES push_poper termino .)


state 131

    (52) expresion -> exp MORETHAN push_poper exp .

    RPAREN          reduce using rule 52 (expresion -> exp MORETHAN push_poper exp .)
    SEMICOLON       reduce using rule 52 (expresion -> exp MORETHAN push_poper exp .)
    COMA            reduce using rule 52 (expresion -> exp MORETHAN push_poper exp .)


state 132

    (53) expresion -> exp DIFFERENT push_poper exp .

    RPAREN          reduce using rule 53 (expresion -> exp DIFFERENT push_poper exp .)
    SEMICOLON       reduce using rule 53 (expresion -> exp DIFFERENT push_poper exp .)
    COMA            reduce using rule 53 (expresion -> exp DIFFERENT push_poper exp .)


state 133

    (51) expresion -> exp LOWERTHAN push_poper exp .

    RPAREN          reduce using rule 51 (expresion -> exp LOWERTHAN push_poper exp .)
    SEMICOLON       reduce using rule 51 (expresion -> exp LOWERTHAN push_poper exp .)
    COMA            reduce using rule 51 (expresion -> exp LOWERTHAN push_poper exp .)


state 134

    (42) comparacion -> ID push_id DOUBLEEQUAL push_poper expresion SEMICOLON .

    ID              reduce using rule 42 (comparacion -> ID push_id DOUBLEEQUAL push_poper expresion SEMICOLON .)
    IF              reduce using rule 42 (comparacion -> ID push_id DOUBLEEQUAL push_poper expresion SEMICOLON .)
    PRINT           reduce using rule 42 (comparacion -> ID push_id DOUBLEEQUAL push_poper expresion SEMICOLON .)
    WHILE           reduce using rule 42 (comparacion -> ID push_id DOUBLEEQUAL push_poper expresion SEMICOLON .)
    RBRACE          reduce using rule 42 (comparacion -> ID push_id DOUBLEEQUAL push_poper expresion SEMICOLON .)


state 135

    (41) asignacion -> ID push_id EQUAL push_poper expresion SEMICOLON .

    ID              reduce using rule 41 (asignacion -> ID push_id EQUAL push_poper expresion SEMICOLON .)
    IF              reduce using rule 41 (asignacion -> ID push_id EQUAL push_poper expresion SEMICOLON .)
    PRINT           reduce using rule 41 (asignacion -> ID push_id EQUAL push_poper expresion SEMICOLON .)
    WHILE           reduce using rule 41 (asignacion -> ID push_id EQUAL push_poper expresion SEMICOLON .)
    RBRACE          reduce using rule 41 (asignacion -> ID push_id EQUAL push_poper expresion SEMICOLON .)


state 136

    (20) bloque -> LBRACE RBRACE .

    ID              reduce using rule 20 (bloque -> LBRACE RBRACE .)
    IF              reduce using rule 20 (bloque -> LBRACE RBRACE .)
    PRINT           reduce using rule 20 (bloque -> LBRACE RBRACE .)
    WHILE           reduce using rule 20 (bloque -> LBRACE RBRACE .)
    RBRACE          reduce using rule 20 (bloque -> LBRACE RBRACE .)
    SEMICOLON       reduce using rule 20 (bloque -> LBRACE RBRACE .)
    ELSE            reduce using rule 20 (bloque -> LBRACE RBRACE .)


state 137

    (21) bloque -> LBRACE bloqueAux . RBRACE

    RBRACE          shift and go to state 143


state 138

    (43) condicion -> IF LPAREN expresion RPAREN bloque SEMICOLON .

    ID              reduce using rule 43 (condicion -> IF LPAREN expresion RPAREN bloque SEMICOLON .)
    IF              reduce using rule 43 (condicion -> IF LPAREN expresion RPAREN bloque SEMICOLON .)
    PRINT           reduce using rule 43 (condicion -> IF LPAREN expresion RPAREN bloque SEMICOLON .)
    WHILE           reduce using rule 43 (condicion -> IF LPAREN expresion RPAREN bloque SEMICOLON .)
    RBRACE          reduce using rule 43 (condicion -> IF LPAREN expresion RPAREN bloque SEMICOLON .)


state 139

    (44) condicion -> IF LPAREN expresion RPAREN bloque ELSE . bloque SEMICOLON
    (20) bloque -> . LBRACE RBRACE
    (21) bloque -> . LBRACE bloqueAux RBRACE

    LBRACE          shift and go to state 119

    bloque                         shift and go to state 144

state 140

    (23) function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE .
    (25) function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE . function
    (22) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE
    (23) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE
    (24) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE function
    (25) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE function
    (26) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE
    (27) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE
    (28) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE function
    (29) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE function

    $end            reduce using rule 23 (function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE .)
    FUNCTION        shift and go to state 18

    function                       shift and go to state 145

state 141

    (28) function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE function .

    $end            reduce using rule 28 (function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE function .)


state 142

    (27) function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux . RBRACE
    (29) function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux . RBRACE function

    RBRACE          shift and go to state 146


state 143

    (21) bloque -> LBRACE bloqueAux RBRACE .

    ID              reduce using rule 21 (bloque -> LBRACE bloqueAux RBRACE .)
    IF              reduce using rule 21 (bloque -> LBRACE bloqueAux RBRACE .)
    PRINT           reduce using rule 21 (bloque -> LBRACE bloqueAux RBRACE .)
    WHILE           reduce using rule 21 (bloque -> LBRACE bloqueAux RBRACE .)
    RBRACE          reduce using rule 21 (bloque -> LBRACE bloqueAux RBRACE .)
    SEMICOLON       reduce using rule 21 (bloque -> LBRACE bloqueAux RBRACE .)
    ELSE            reduce using rule 21 (bloque -> LBRACE bloqueAux RBRACE .)


state 144

    (44) condicion -> IF LPAREN expresion RPAREN bloque ELSE bloque . SEMICOLON

    SEMICOLON       shift and go to state 147


state 145

    (25) function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE function .

    $end            reduce using rule 25 (function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE function .)


state 146

    (27) function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE .
    (29) function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE . function
    (22) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE
    (23) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE
    (24) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE function
    (25) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE function
    (26) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE
    (27) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE
    (28) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE function
    (29) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE function

    $end            reduce using rule 27 (function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE .)
    FUNCTION        shift and go to state 18

    function                       shift and go to state 148

state 147

    (44) condicion -> IF LPAREN expresion RPAREN bloque ELSE bloque SEMICOLON .

    ID              reduce using rule 44 (condicion -> IF LPAREN expresion RPAREN bloque ELSE bloque SEMICOLON .)
    IF              reduce using rule 44 (condicion -> IF LPAREN expresion RPAREN bloque ELSE bloque SEMICOLON .)
    PRINT           reduce using rule 44 (condicion -> IF LPAREN expresion RPAREN bloque ELSE bloque SEMICOLON .)
    WHILE           reduce using rule 44 (condicion -> IF LPAREN expresion RPAREN bloque ELSE bloque SEMICOLON .)
    RBRACE          reduce using rule 44 (condicion -> IF LPAREN expresion RPAREN bloque ELSE bloque SEMICOLON .)


state 148

    (29) function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE function .

    $end            reduce using rule 29 (function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE function .)

