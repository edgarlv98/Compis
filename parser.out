Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    FOR
    OR

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID COLON vars main function
Rule 2     program -> PROGRAM ID COLON main function
Rule 3     program -> PROGRAM ID COLON vars main
Rule 4     program -> PROGRAM ID COLON main
Rule 5     main -> nomMain LPAREN RPAREN LBRACE bloqueAux RBRACE
Rule 6     main -> nomMain LPAREN RPAREN LBRACE vars bloqueAux RBRACE
Rule 7     nomMain -> MAIN
Rule 8     vars -> VAR varAux1
Rule 9     varAux1 -> tipo varAux2 SEMICOLON
Rule 10    varAux1 -> tipo varAux2 SEMICOLON varAux1
Rule 11    varAux2 -> ID
Rule 12    varAux2 -> ID COMA varAux2
Rule 13    tipo -> INT
Rule 14    tipo -> FLOAT
Rule 15    tipo -> CHAR
Rule 16    tipoFunc -> INT
Rule 17    tipoFunc -> FLOAT
Rule 18    tipoFunc -> CHAR
Rule 19    tipoFunc -> VOID
Rule 20    bloque -> LBRACE RBRACE
Rule 21    bloque -> LBRACE bloqueAux RBRACE
Rule 22    function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE
Rule 23    function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE
Rule 24    function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE function
Rule 25    function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE function
Rule 26    function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE
Rule 27    function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE
Rule 28    function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE function
Rule 29    function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE function
Rule 30    param -> tipo ID
Rule 31    param -> tipo ID COMA param
Rule 32    nomFunc -> ID
Rule 33    bloqueAux -> estatuto
Rule 34    bloqueAux -> estatuto bloqueAux
Rule 35    while -> WHILE LPAREN expresion RPAREN bloque
Rule 36    estatuto -> asignacion
Rule 37    estatuto -> condicion
Rule 38    estatuto -> escritura
Rule 39    estatuto -> while
Rule 40    estatuto -> comparacion
Rule 41    asignacion -> ID push_id EQUAL push_poper expresion create_asign SEMICOLON
Rule 42    create_asign -> <empty>
Rule 43    comparacion -> ID push_id DOUBLEEQUAL push_poper expresion SEMICOLON
Rule 44    condicion -> IF LPAREN expresion RPAREN cond bloque SEMICOLON condFinal
Rule 45    condicion -> IF LPAREN expresion RPAREN cond bloque ELSE condElse bloque SEMICOLON condFinal
Rule 46    cond -> <empty>
Rule 47    condElse -> <empty>
Rule 48    condFinal -> <empty>
Rule 49    escritura -> PRINT push_poper LPAREN exp RPAREN quad_print SEMICOLON
Rule 50    quad_print -> <empty>
Rule 51    escrituraAux -> expresion
Rule 52    escrituraAux -> CTE_STRING
Rule 53    escrituraAux -> expresion COMA escrituraAux
Rule 54    escrituraAux -> CTE_STRING COMA escrituraAux
Rule 55    expresion -> exp
Rule 56    expresion -> exp LOWERTHAN push_poper exp quad_comp
Rule 57    expresion -> exp MORETHAN push_poper exp quad_comp
Rule 58    expresion -> exp DIFFERENT push_poper exp quad_comp
Rule 59    quad_comp -> <empty>
Rule 60    exp -> termino quad_term
Rule 61    exp -> termino quad_term exp1
Rule 62    exp1 -> PLUS push_poper exp
Rule 63    exp1 -> MINUS push_poper exp
Rule 64    quad_term -> <empty>
Rule 65    quad_fact -> <empty>
Rule 66    termino -> factor quad_fact
Rule 67    termino -> factor quad_fact termino1
Rule 68    termino1 -> TIMES push_poper termino
Rule 69    termino1 -> DIVIDE push_poper termino
Rule 70    factor -> LPAREN expresion RPAREN
Rule 71    factor -> factorAux
Rule 72    factorAux -> PLUS push_poper var_cte
Rule 73    factorAux -> MINUS push_poper var_cte
Rule 74    factorAux -> var_cte
Rule 75    push_id -> <empty>
Rule 76    push_cte -> <empty>
Rule 77    push_poper -> <empty>
Rule 78    var_cte -> ID push_id
Rule 79    var_cte -> CTE_I push_cte
Rule 80    var_cte -> CTE_F push_cte

Terminals, with rules where they appear

AND                  : 
CHAR                 : 15 18
COLON                : 1 2 3 4
COMA                 : 12 31 53 54
CTE_F                : 80
CTE_I                : 79
CTE_STRING           : 52 54
DIFFERENT            : 58
DIVIDE               : 69
DOUBLEEQUAL          : 43
ELSE                 : 45
EQUAL                : 41
FLOAT                : 14 17
FOR                  : 
FUNCTION             : 22 23 24 25 26 27 28 29
ID                   : 1 2 3 4 11 12 30 31 32 41 43 78
IF                   : 44 45
INT                  : 13 16
LBRACE               : 5 6 20 21 22 23 24 25 26 27 28 29
LOWERTHAN            : 56
LPAREN               : 5 6 22 23 24 25 26 27 28 29 35 44 45 49 70
MAIN                 : 7
MINUS                : 63 73
MORETHAN             : 57
OR                   : 
PLUS                 : 62 72
PRINT                : 49
PROGRAM              : 1 2 3 4
RBRACE               : 5 6 20 21 22 23 24 25 26 27 28 29
RPAREN               : 5 6 22 23 24 25 26 27 28 29 35 44 45 49 70
SEMICOLON            : 9 10 41 43 44 45 49
TIMES                : 68
VAR                  : 8
VOID                 : 19
WHILE                : 35
error                : 

Nonterminals, with rules where they appear

asignacion           : 36
bloque               : 35 44 45 45
bloqueAux            : 5 6 21 23 25 27 29 34
comparacion          : 40
cond                 : 44 45
condElse             : 45
condFinal            : 44 45
condicion            : 37
create_asign         : 41
escritura            : 38
escrituraAux         : 53 54
estatuto             : 33 34
exp                  : 49 55 56 56 57 57 58 58 62 63
exp1                 : 61
expresion            : 35 41 43 44 45 51 53 70
factor               : 66 67
factorAux            : 71
function             : 1 2 24 25 28 29
main                 : 1 2 3 4
nomFunc              : 22 23 24 25 26 27 28 29
nomMain              : 5 6
param                : 26 27 28 29 31
program              : 0
push_cte             : 79 80
push_id              : 41 43 78
push_poper           : 41 43 49 56 57 58 62 63 68 69 72 73
quad_comp            : 56 57 58
quad_fact            : 66 67
quad_print           : 49
quad_term            : 60 61
termino              : 60 61 68 69
termino1             : 67
tipo                 : 9 10 30 31
tipoFunc             : 22 23 24 25 26 27 28 29
varAux1              : 8 10
varAux2              : 9 10 12
var_cte              : 72 73 74
vars                 : 1 3 6 23 25 27 29
while                : 39

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID COLON vars main function
    (2) program -> . PROGRAM ID COLON main function
    (3) program -> . PROGRAM ID COLON vars main
    (4) program -> . PROGRAM ID COLON main

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID COLON vars main function
    (2) program -> PROGRAM . ID COLON main function
    (3) program -> PROGRAM . ID COLON vars main
    (4) program -> PROGRAM . ID COLON main

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . COLON vars main function
    (2) program -> PROGRAM ID . COLON main function
    (3) program -> PROGRAM ID . COLON vars main
    (4) program -> PROGRAM ID . COLON main

    COLON           shift and go to state 4


state 4

    (1) program -> PROGRAM ID COLON . vars main function
    (2) program -> PROGRAM ID COLON . main function
    (3) program -> PROGRAM ID COLON . vars main
    (4) program -> PROGRAM ID COLON . main
    (8) vars -> . VAR varAux1
    (5) main -> . nomMain LPAREN RPAREN LBRACE bloqueAux RBRACE
    (6) main -> . nomMain LPAREN RPAREN LBRACE vars bloqueAux RBRACE
    (7) nomMain -> . MAIN

    VAR             shift and go to state 7
    MAIN            shift and go to state 9

    vars                           shift and go to state 5
    main                           shift and go to state 6
    nomMain                        shift and go to state 8

state 5

    (1) program -> PROGRAM ID COLON vars . main function
    (3) program -> PROGRAM ID COLON vars . main
    (5) main -> . nomMain LPAREN RPAREN LBRACE bloqueAux RBRACE
    (6) main -> . nomMain LPAREN RPAREN LBRACE vars bloqueAux RBRACE
    (7) nomMain -> . MAIN

    MAIN            shift and go to state 9

    main                           shift and go to state 10
    nomMain                        shift and go to state 8

state 6

    (2) program -> PROGRAM ID COLON main . function
    (4) program -> PROGRAM ID COLON main .
    (22) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE
    (23) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE
    (24) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE function
    (25) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE function
    (26) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE
    (27) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE
    (28) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE function
    (29) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE function

    $end            reduce using rule 4 (program -> PROGRAM ID COLON main .)
    FUNCTION        shift and go to state 12

    function                       shift and go to state 11

state 7

    (8) vars -> VAR . varAux1
    (9) varAux1 -> . tipo varAux2 SEMICOLON
    (10) varAux1 -> . tipo varAux2 SEMICOLON varAux1
    (13) tipo -> . INT
    (14) tipo -> . FLOAT
    (15) tipo -> . CHAR

    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17

    varAux1                        shift and go to state 13
    tipo                           shift and go to state 14

state 8

    (5) main -> nomMain . LPAREN RPAREN LBRACE bloqueAux RBRACE
    (6) main -> nomMain . LPAREN RPAREN LBRACE vars bloqueAux RBRACE

    LPAREN          shift and go to state 18


state 9

    (7) nomMain -> MAIN .

    LPAREN          reduce using rule 7 (nomMain -> MAIN .)


state 10

    (1) program -> PROGRAM ID COLON vars main . function
    (3) program -> PROGRAM ID COLON vars main .
    (22) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE
    (23) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE
    (24) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE function
    (25) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE function
    (26) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE
    (27) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE
    (28) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE function
    (29) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE function

    $end            reduce using rule 3 (program -> PROGRAM ID COLON vars main .)
    FUNCTION        shift and go to state 12

    function                       shift and go to state 19

state 11

    (2) program -> PROGRAM ID COLON main function .

    $end            reduce using rule 2 (program -> PROGRAM ID COLON main function .)


state 12

    (22) function -> FUNCTION . tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE
    (23) function -> FUNCTION . tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE
    (24) function -> FUNCTION . tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE function
    (25) function -> FUNCTION . tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE function
    (26) function -> FUNCTION . tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE
    (27) function -> FUNCTION . tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE
    (28) function -> FUNCTION . tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE function
    (29) function -> FUNCTION . tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE function
    (16) tipoFunc -> . INT
    (17) tipoFunc -> . FLOAT
    (18) tipoFunc -> . CHAR
    (19) tipoFunc -> . VOID

    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    CHAR            shift and go to state 23
    VOID            shift and go to state 24

    tipoFunc                       shift and go to state 20

state 13

    (8) vars -> VAR varAux1 .

    MAIN            reduce using rule 8 (vars -> VAR varAux1 .)
    ID              reduce using rule 8 (vars -> VAR varAux1 .)
    IF              reduce using rule 8 (vars -> VAR varAux1 .)
    PRINT           reduce using rule 8 (vars -> VAR varAux1 .)
    WHILE           reduce using rule 8 (vars -> VAR varAux1 .)


state 14

    (9) varAux1 -> tipo . varAux2 SEMICOLON
    (10) varAux1 -> tipo . varAux2 SEMICOLON varAux1
    (11) varAux2 -> . ID
    (12) varAux2 -> . ID COMA varAux2

    ID              shift and go to state 26

    varAux2                        shift and go to state 25

state 15

    (13) tipo -> INT .

    ID              reduce using rule 13 (tipo -> INT .)


state 16

    (14) tipo -> FLOAT .

    ID              reduce using rule 14 (tipo -> FLOAT .)


state 17

    (15) tipo -> CHAR .

    ID              reduce using rule 15 (tipo -> CHAR .)


state 18

    (5) main -> nomMain LPAREN . RPAREN LBRACE bloqueAux RBRACE
    (6) main -> nomMain LPAREN . RPAREN LBRACE vars bloqueAux RBRACE

    RPAREN          shift and go to state 27


state 19

    (1) program -> PROGRAM ID COLON vars main function .

    $end            reduce using rule 1 (program -> PROGRAM ID COLON vars main function .)


state 20

    (22) function -> FUNCTION tipoFunc . nomFunc LPAREN RPAREN LBRACE RBRACE
    (23) function -> FUNCTION tipoFunc . nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE
    (24) function -> FUNCTION tipoFunc . nomFunc LPAREN RPAREN LBRACE RBRACE function
    (25) function -> FUNCTION tipoFunc . nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE function
    (26) function -> FUNCTION tipoFunc . nomFunc LPAREN param RPAREN LBRACE RBRACE
    (27) function -> FUNCTION tipoFunc . nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE
    (28) function -> FUNCTION tipoFunc . nomFunc LPAREN param RPAREN LBRACE RBRACE function
    (29) function -> FUNCTION tipoFunc . nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE function
    (32) nomFunc -> . ID

    ID              shift and go to state 29

    nomFunc                        shift and go to state 28

state 21

    (16) tipoFunc -> INT .

    ID              reduce using rule 16 (tipoFunc -> INT .)


state 22

    (17) tipoFunc -> FLOAT .

    ID              reduce using rule 17 (tipoFunc -> FLOAT .)


state 23

    (18) tipoFunc -> CHAR .

    ID              reduce using rule 18 (tipoFunc -> CHAR .)


state 24

    (19) tipoFunc -> VOID .

    ID              reduce using rule 19 (tipoFunc -> VOID .)


state 25

    (9) varAux1 -> tipo varAux2 . SEMICOLON
    (10) varAux1 -> tipo varAux2 . SEMICOLON varAux1

    SEMICOLON       shift and go to state 30


state 26

    (11) varAux2 -> ID .
    (12) varAux2 -> ID . COMA varAux2

    SEMICOLON       reduce using rule 11 (varAux2 -> ID .)
    COMA            shift and go to state 31


state 27

    (5) main -> nomMain LPAREN RPAREN . LBRACE bloqueAux RBRACE
    (6) main -> nomMain LPAREN RPAREN . LBRACE vars bloqueAux RBRACE

    LBRACE          shift and go to state 32


state 28

    (22) function -> FUNCTION tipoFunc nomFunc . LPAREN RPAREN LBRACE RBRACE
    (23) function -> FUNCTION tipoFunc nomFunc . LPAREN RPAREN LBRACE vars bloqueAux RBRACE
    (24) function -> FUNCTION tipoFunc nomFunc . LPAREN RPAREN LBRACE RBRACE function
    (25) function -> FUNCTION tipoFunc nomFunc . LPAREN RPAREN LBRACE vars bloqueAux RBRACE function
    (26) function -> FUNCTION tipoFunc nomFunc . LPAREN param RPAREN LBRACE RBRACE
    (27) function -> FUNCTION tipoFunc nomFunc . LPAREN param RPAREN LBRACE vars bloqueAux RBRACE
    (28) function -> FUNCTION tipoFunc nomFunc . LPAREN param RPAREN LBRACE RBRACE function
    (29) function -> FUNCTION tipoFunc nomFunc . LPAREN param RPAREN LBRACE vars bloqueAux RBRACE function

    LPAREN          shift and go to state 33


state 29

    (32) nomFunc -> ID .

    LPAREN          reduce using rule 32 (nomFunc -> ID .)


state 30

    (9) varAux1 -> tipo varAux2 SEMICOLON .
    (10) varAux1 -> tipo varAux2 SEMICOLON . varAux1
    (9) varAux1 -> . tipo varAux2 SEMICOLON
    (10) varAux1 -> . tipo varAux2 SEMICOLON varAux1
    (13) tipo -> . INT
    (14) tipo -> . FLOAT
    (15) tipo -> . CHAR

    MAIN            reduce using rule 9 (varAux1 -> tipo varAux2 SEMICOLON .)
    ID              reduce using rule 9 (varAux1 -> tipo varAux2 SEMICOLON .)
    IF              reduce using rule 9 (varAux1 -> tipo varAux2 SEMICOLON .)
    PRINT           reduce using rule 9 (varAux1 -> tipo varAux2 SEMICOLON .)
    WHILE           reduce using rule 9 (varAux1 -> tipo varAux2 SEMICOLON .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17

    tipo                           shift and go to state 14
    varAux1                        shift and go to state 34

state 31

    (12) varAux2 -> ID COMA . varAux2
    (11) varAux2 -> . ID
    (12) varAux2 -> . ID COMA varAux2

    ID              shift and go to state 26

    varAux2                        shift and go to state 35

state 32

    (5) main -> nomMain LPAREN RPAREN LBRACE . bloqueAux RBRACE
    (6) main -> nomMain LPAREN RPAREN LBRACE . vars bloqueAux RBRACE
    (33) bloqueAux -> . estatuto
    (34) bloqueAux -> . estatuto bloqueAux
    (8) vars -> . VAR varAux1
    (36) estatuto -> . asignacion
    (37) estatuto -> . condicion
    (38) estatuto -> . escritura
    (39) estatuto -> . while
    (40) estatuto -> . comparacion
    (41) asignacion -> . ID push_id EQUAL push_poper expresion create_asign SEMICOLON
    (44) condicion -> . IF LPAREN expresion RPAREN cond bloque SEMICOLON condFinal
    (45) condicion -> . IF LPAREN expresion RPAREN cond bloque ELSE condElse bloque SEMICOLON condFinal
    (49) escritura -> . PRINT push_poper LPAREN exp RPAREN quad_print SEMICOLON
    (35) while -> . WHILE LPAREN expresion RPAREN bloque
    (43) comparacion -> . ID push_id DOUBLEEQUAL push_poper expresion SEMICOLON

    VAR             shift and go to state 7
    ID              shift and go to state 44
    IF              shift and go to state 45
    PRINT           shift and go to state 46
    WHILE           shift and go to state 47

    bloqueAux                      shift and go to state 36
    vars                           shift and go to state 37
    estatuto                       shift and go to state 38
    asignacion                     shift and go to state 39
    condicion                      shift and go to state 40
    escritura                      shift and go to state 41
    while                          shift and go to state 42
    comparacion                    shift and go to state 43

state 33

    (22) function -> FUNCTION tipoFunc nomFunc LPAREN . RPAREN LBRACE RBRACE
    (23) function -> FUNCTION tipoFunc nomFunc LPAREN . RPAREN LBRACE vars bloqueAux RBRACE
    (24) function -> FUNCTION tipoFunc nomFunc LPAREN . RPAREN LBRACE RBRACE function
    (25) function -> FUNCTION tipoFunc nomFunc LPAREN . RPAREN LBRACE vars bloqueAux RBRACE function
    (26) function -> FUNCTION tipoFunc nomFunc LPAREN . param RPAREN LBRACE RBRACE
    (27) function -> FUNCTION tipoFunc nomFunc LPAREN . param RPAREN LBRACE vars bloqueAux RBRACE
    (28) function -> FUNCTION tipoFunc nomFunc LPAREN . param RPAREN LBRACE RBRACE function
    (29) function -> FUNCTION tipoFunc nomFunc LPAREN . param RPAREN LBRACE vars bloqueAux RBRACE function
    (30) param -> . tipo ID
    (31) param -> . tipo ID COMA param
    (13) tipo -> . INT
    (14) tipo -> . FLOAT
    (15) tipo -> . CHAR

    RPAREN          shift and go to state 48
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17

    param                          shift and go to state 49
    tipo                           shift and go to state 50

state 34

    (10) varAux1 -> tipo varAux2 SEMICOLON varAux1 .

    MAIN            reduce using rule 10 (varAux1 -> tipo varAux2 SEMICOLON varAux1 .)
    ID              reduce using rule 10 (varAux1 -> tipo varAux2 SEMICOLON varAux1 .)
    IF              reduce using rule 10 (varAux1 -> tipo varAux2 SEMICOLON varAux1 .)
    PRINT           reduce using rule 10 (varAux1 -> tipo varAux2 SEMICOLON varAux1 .)
    WHILE           reduce using rule 10 (varAux1 -> tipo varAux2 SEMICOLON varAux1 .)


state 35

    (12) varAux2 -> ID COMA varAux2 .

    SEMICOLON       reduce using rule 12 (varAux2 -> ID COMA varAux2 .)


state 36

    (5) main -> nomMain LPAREN RPAREN LBRACE bloqueAux . RBRACE

    RBRACE          shift and go to state 51


state 37

    (6) main -> nomMain LPAREN RPAREN LBRACE vars . bloqueAux RBRACE
    (33) bloqueAux -> . estatuto
    (34) bloqueAux -> . estatuto bloqueAux
    (36) estatuto -> . asignacion
    (37) estatuto -> . condicion
    (38) estatuto -> . escritura
    (39) estatuto -> . while
    (40) estatuto -> . comparacion
    (41) asignacion -> . ID push_id EQUAL push_poper expresion create_asign SEMICOLON
    (44) condicion -> . IF LPAREN expresion RPAREN cond bloque SEMICOLON condFinal
    (45) condicion -> . IF LPAREN expresion RPAREN cond bloque ELSE condElse bloque SEMICOLON condFinal
    (49) escritura -> . PRINT push_poper LPAREN exp RPAREN quad_print SEMICOLON
    (35) while -> . WHILE LPAREN expresion RPAREN bloque
    (43) comparacion -> . ID push_id DOUBLEEQUAL push_poper expresion SEMICOLON

    ID              shift and go to state 44
    IF              shift and go to state 45
    PRINT           shift and go to state 46
    WHILE           shift and go to state 47

    bloqueAux                      shift and go to state 52
    estatuto                       shift and go to state 38
    asignacion                     shift and go to state 39
    condicion                      shift and go to state 40
    escritura                      shift and go to state 41
    while                          shift and go to state 42
    comparacion                    shift and go to state 43

state 38

    (33) bloqueAux -> estatuto .
    (34) bloqueAux -> estatuto . bloqueAux
    (33) bloqueAux -> . estatuto
    (34) bloqueAux -> . estatuto bloqueAux
    (36) estatuto -> . asignacion
    (37) estatuto -> . condicion
    (38) estatuto -> . escritura
    (39) estatuto -> . while
    (40) estatuto -> . comparacion
    (41) asignacion -> . ID push_id EQUAL push_poper expresion create_asign SEMICOLON
    (44) condicion -> . IF LPAREN expresion RPAREN cond bloque SEMICOLON condFinal
    (45) condicion -> . IF LPAREN expresion RPAREN cond bloque ELSE condElse bloque SEMICOLON condFinal
    (49) escritura -> . PRINT push_poper LPAREN exp RPAREN quad_print SEMICOLON
    (35) while -> . WHILE LPAREN expresion RPAREN bloque
    (43) comparacion -> . ID push_id DOUBLEEQUAL push_poper expresion SEMICOLON

    RBRACE          reduce using rule 33 (bloqueAux -> estatuto .)
    ID              shift and go to state 44
    IF              shift and go to state 45
    PRINT           shift and go to state 46
    WHILE           shift and go to state 47

    estatuto                       shift and go to state 38
    bloqueAux                      shift and go to state 53
    asignacion                     shift and go to state 39
    condicion                      shift and go to state 40
    escritura                      shift and go to state 41
    while                          shift and go to state 42
    comparacion                    shift and go to state 43

state 39

    (36) estatuto -> asignacion .

    ID              reduce using rule 36 (estatuto -> asignacion .)
    IF              reduce using rule 36 (estatuto -> asignacion .)
    PRINT           reduce using rule 36 (estatuto -> asignacion .)
    WHILE           reduce using rule 36 (estatuto -> asignacion .)
    RBRACE          reduce using rule 36 (estatuto -> asignacion .)


state 40

    (37) estatuto -> condicion .

    ID              reduce using rule 37 (estatuto -> condicion .)
    IF              reduce using rule 37 (estatuto -> condicion .)
    PRINT           reduce using rule 37 (estatuto -> condicion .)
    WHILE           reduce using rule 37 (estatuto -> condicion .)
    RBRACE          reduce using rule 37 (estatuto -> condicion .)


state 41

    (38) estatuto -> escritura .

    ID              reduce using rule 38 (estatuto -> escritura .)
    IF              reduce using rule 38 (estatuto -> escritura .)
    PRINT           reduce using rule 38 (estatuto -> escritura .)
    WHILE           reduce using rule 38 (estatuto -> escritura .)
    RBRACE          reduce using rule 38 (estatuto -> escritura .)


state 42

    (39) estatuto -> while .

    ID              reduce using rule 39 (estatuto -> while .)
    IF              reduce using rule 39 (estatuto -> while .)
    PRINT           reduce using rule 39 (estatuto -> while .)
    WHILE           reduce using rule 39 (estatuto -> while .)
    RBRACE          reduce using rule 39 (estatuto -> while .)


state 43

    (40) estatuto -> comparacion .

    ID              reduce using rule 40 (estatuto -> comparacion .)
    IF              reduce using rule 40 (estatuto -> comparacion .)
    PRINT           reduce using rule 40 (estatuto -> comparacion .)
    WHILE           reduce using rule 40 (estatuto -> comparacion .)
    RBRACE          reduce using rule 40 (estatuto -> comparacion .)


state 44

    (41) asignacion -> ID . push_id EQUAL push_poper expresion create_asign SEMICOLON
    (43) comparacion -> ID . push_id DOUBLEEQUAL push_poper expresion SEMICOLON
    (75) push_id -> .

    EQUAL           reduce using rule 75 (push_id -> .)
    DOUBLEEQUAL     reduce using rule 75 (push_id -> .)

    push_id                        shift and go to state 54

state 45

    (44) condicion -> IF . LPAREN expresion RPAREN cond bloque SEMICOLON condFinal
    (45) condicion -> IF . LPAREN expresion RPAREN cond bloque ELSE condElse bloque SEMICOLON condFinal

    LPAREN          shift and go to state 55


state 46

    (49) escritura -> PRINT . push_poper LPAREN exp RPAREN quad_print SEMICOLON
    (77) push_poper -> .

    LPAREN          reduce using rule 77 (push_poper -> .)

    push_poper                     shift and go to state 56

state 47

    (35) while -> WHILE . LPAREN expresion RPAREN bloque

    LPAREN          shift and go to state 57


state 48

    (22) function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN . LBRACE RBRACE
    (23) function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN . LBRACE vars bloqueAux RBRACE
    (24) function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN . LBRACE RBRACE function
    (25) function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN . LBRACE vars bloqueAux RBRACE function

    LBRACE          shift and go to state 58


state 49

    (26) function -> FUNCTION tipoFunc nomFunc LPAREN param . RPAREN LBRACE RBRACE
    (27) function -> FUNCTION tipoFunc nomFunc LPAREN param . RPAREN LBRACE vars bloqueAux RBRACE
    (28) function -> FUNCTION tipoFunc nomFunc LPAREN param . RPAREN LBRACE RBRACE function
    (29) function -> FUNCTION tipoFunc nomFunc LPAREN param . RPAREN LBRACE vars bloqueAux RBRACE function

    RPAREN          shift and go to state 59


state 50

    (30) param -> tipo . ID
    (31) param -> tipo . ID COMA param

    ID              shift and go to state 60


state 51

    (5) main -> nomMain LPAREN RPAREN LBRACE bloqueAux RBRACE .

    FUNCTION        reduce using rule 5 (main -> nomMain LPAREN RPAREN LBRACE bloqueAux RBRACE .)
    $end            reduce using rule 5 (main -> nomMain LPAREN RPAREN LBRACE bloqueAux RBRACE .)


state 52

    (6) main -> nomMain LPAREN RPAREN LBRACE vars bloqueAux . RBRACE

    RBRACE          shift and go to state 61


state 53

    (34) bloqueAux -> estatuto bloqueAux .

    RBRACE          reduce using rule 34 (bloqueAux -> estatuto bloqueAux .)


state 54

    (41) asignacion -> ID push_id . EQUAL push_poper expresion create_asign SEMICOLON
    (43) comparacion -> ID push_id . DOUBLEEQUAL push_poper expresion SEMICOLON

    EQUAL           shift and go to state 62
    DOUBLEEQUAL     shift and go to state 63


state 55

    (44) condicion -> IF LPAREN . expresion RPAREN cond bloque SEMICOLON condFinal
    (45) condicion -> IF LPAREN . expresion RPAREN cond bloque ELSE condElse bloque SEMICOLON condFinal
    (55) expresion -> . exp
    (56) expresion -> . exp LOWERTHAN push_poper exp quad_comp
    (57) expresion -> . exp MORETHAN push_poper exp quad_comp
    (58) expresion -> . exp DIFFERENT push_poper exp quad_comp
    (60) exp -> . termino quad_term
    (61) exp -> . termino quad_term exp1
    (66) termino -> . factor quad_fact
    (67) termino -> . factor quad_fact termino1
    (70) factor -> . LPAREN expresion RPAREN
    (71) factor -> . factorAux
    (72) factorAux -> . PLUS push_poper var_cte
    (73) factorAux -> . MINUS push_poper var_cte
    (74) factorAux -> . var_cte
    (78) var_cte -> . ID push_id
    (79) var_cte -> . CTE_I push_cte
    (80) var_cte -> . CTE_F push_cte

    LPAREN          shift and go to state 64
    PLUS            shift and go to state 70
    MINUS           shift and go to state 72
    ID              shift and go to state 73
    CTE_I           shift and go to state 74
    CTE_F           shift and go to state 75

    expresion                      shift and go to state 65
    exp                            shift and go to state 66
    termino                        shift and go to state 67
    factor                         shift and go to state 68
    factorAux                      shift and go to state 69
    var_cte                        shift and go to state 71

state 56

    (49) escritura -> PRINT push_poper . LPAREN exp RPAREN quad_print SEMICOLON

    LPAREN          shift and go to state 76


state 57

    (35) while -> WHILE LPAREN . expresion RPAREN bloque
    (55) expresion -> . exp
    (56) expresion -> . exp LOWERTHAN push_poper exp quad_comp
    (57) expresion -> . exp MORETHAN push_poper exp quad_comp
    (58) expresion -> . exp DIFFERENT push_poper exp quad_comp
    (60) exp -> . termino quad_term
    (61) exp -> . termino quad_term exp1
    (66) termino -> . factor quad_fact
    (67) termino -> . factor quad_fact termino1
    (70) factor -> . LPAREN expresion RPAREN
    (71) factor -> . factorAux
    (72) factorAux -> . PLUS push_poper var_cte
    (73) factorAux -> . MINUS push_poper var_cte
    (74) factorAux -> . var_cte
    (78) var_cte -> . ID push_id
    (79) var_cte -> . CTE_I push_cte
    (80) var_cte -> . CTE_F push_cte

    LPAREN          shift and go to state 64
    PLUS            shift and go to state 70
    MINUS           shift and go to state 72
    ID              shift and go to state 73
    CTE_I           shift and go to state 74
    CTE_F           shift and go to state 75

    expresion                      shift and go to state 77
    exp                            shift and go to state 66
    termino                        shift and go to state 67
    factor                         shift and go to state 68
    factorAux                      shift and go to state 69
    var_cte                        shift and go to state 71

state 58

    (22) function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE . RBRACE
    (23) function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE . vars bloqueAux RBRACE
    (24) function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE . RBRACE function
    (25) function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE . vars bloqueAux RBRACE function
    (8) vars -> . VAR varAux1

    RBRACE          shift and go to state 78
    VAR             shift and go to state 7

    vars                           shift and go to state 79

state 59

    (26) function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN . LBRACE RBRACE
    (27) function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN . LBRACE vars bloqueAux RBRACE
    (28) function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN . LBRACE RBRACE function
    (29) function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN . LBRACE vars bloqueAux RBRACE function

    LBRACE          shift and go to state 80


state 60

    (30) param -> tipo ID .
    (31) param -> tipo ID . COMA param

    RPAREN          reduce using rule 30 (param -> tipo ID .)
    COMA            shift and go to state 81


state 61

    (6) main -> nomMain LPAREN RPAREN LBRACE vars bloqueAux RBRACE .

    FUNCTION        reduce using rule 6 (main -> nomMain LPAREN RPAREN LBRACE vars bloqueAux RBRACE .)
    $end            reduce using rule 6 (main -> nomMain LPAREN RPAREN LBRACE vars bloqueAux RBRACE .)


state 62

    (41) asignacion -> ID push_id EQUAL . push_poper expresion create_asign SEMICOLON
    (77) push_poper -> .

    LPAREN          reduce using rule 77 (push_poper -> .)
    PLUS            reduce using rule 77 (push_poper -> .)
    MINUS           reduce using rule 77 (push_poper -> .)
    ID              reduce using rule 77 (push_poper -> .)
    CTE_I           reduce using rule 77 (push_poper -> .)
    CTE_F           reduce using rule 77 (push_poper -> .)

    push_poper                     shift and go to state 82

state 63

    (43) comparacion -> ID push_id DOUBLEEQUAL . push_poper expresion SEMICOLON
    (77) push_poper -> .

    LPAREN          reduce using rule 77 (push_poper -> .)
    PLUS            reduce using rule 77 (push_poper -> .)
    MINUS           reduce using rule 77 (push_poper -> .)
    ID              reduce using rule 77 (push_poper -> .)
    CTE_I           reduce using rule 77 (push_poper -> .)
    CTE_F           reduce using rule 77 (push_poper -> .)

    push_poper                     shift and go to state 83

state 64

    (70) factor -> LPAREN . expresion RPAREN
    (55) expresion -> . exp
    (56) expresion -> . exp LOWERTHAN push_poper exp quad_comp
    (57) expresion -> . exp MORETHAN push_poper exp quad_comp
    (58) expresion -> . exp DIFFERENT push_poper exp quad_comp
    (60) exp -> . termino quad_term
    (61) exp -> . termino quad_term exp1
    (66) termino -> . factor quad_fact
    (67) termino -> . factor quad_fact termino1
    (70) factor -> . LPAREN expresion RPAREN
    (71) factor -> . factorAux
    (72) factorAux -> . PLUS push_poper var_cte
    (73) factorAux -> . MINUS push_poper var_cte
    (74) factorAux -> . var_cte
    (78) var_cte -> . ID push_id
    (79) var_cte -> . CTE_I push_cte
    (80) var_cte -> . CTE_F push_cte

    LPAREN          shift and go to state 64
    PLUS            shift and go to state 70
    MINUS           shift and go to state 72
    ID              shift and go to state 73
    CTE_I           shift and go to state 74
    CTE_F           shift and go to state 75

    expresion                      shift and go to state 84
    exp                            shift and go to state 66
    termino                        shift and go to state 67
    factor                         shift and go to state 68
    factorAux                      shift and go to state 69
    var_cte                        shift and go to state 71

state 65

    (44) condicion -> IF LPAREN expresion . RPAREN cond bloque SEMICOLON condFinal
    (45) condicion -> IF LPAREN expresion . RPAREN cond bloque ELSE condElse bloque SEMICOLON condFinal

    RPAREN          shift and go to state 85


state 66

    (55) expresion -> exp .
    (56) expresion -> exp . LOWERTHAN push_poper exp quad_comp
    (57) expresion -> exp . MORETHAN push_poper exp quad_comp
    (58) expresion -> exp . DIFFERENT push_poper exp quad_comp

    RPAREN          reduce using rule 55 (expresion -> exp .)
    SEMICOLON       reduce using rule 55 (expresion -> exp .)
    LOWERTHAN       shift and go to state 86
    MORETHAN        shift and go to state 87
    DIFFERENT       shift and go to state 88


state 67

    (60) exp -> termino . quad_term
    (61) exp -> termino . quad_term exp1
    (64) quad_term -> .

    PLUS            reduce using rule 64 (quad_term -> .)
    MINUS           reduce using rule 64 (quad_term -> .)
    LOWERTHAN       reduce using rule 64 (quad_term -> .)
    MORETHAN        reduce using rule 64 (quad_term -> .)
    DIFFERENT       reduce using rule 64 (quad_term -> .)
    RPAREN          reduce using rule 64 (quad_term -> .)
    SEMICOLON       reduce using rule 64 (quad_term -> .)

    quad_term                      shift and go to state 89

state 68

    (66) termino -> factor . quad_fact
    (67) termino -> factor . quad_fact termino1
    (65) quad_fact -> .

    TIMES           reduce using rule 65 (quad_fact -> .)
    DIVIDE          reduce using rule 65 (quad_fact -> .)
    PLUS            reduce using rule 65 (quad_fact -> .)
    MINUS           reduce using rule 65 (quad_fact -> .)
    LOWERTHAN       reduce using rule 65 (quad_fact -> .)
    MORETHAN        reduce using rule 65 (quad_fact -> .)
    DIFFERENT       reduce using rule 65 (quad_fact -> .)
    RPAREN          reduce using rule 65 (quad_fact -> .)
    SEMICOLON       reduce using rule 65 (quad_fact -> .)

    quad_fact                      shift and go to state 90

state 69

    (71) factor -> factorAux .

    TIMES           reduce using rule 71 (factor -> factorAux .)
    DIVIDE          reduce using rule 71 (factor -> factorAux .)
    PLUS            reduce using rule 71 (factor -> factorAux .)
    MINUS           reduce using rule 71 (factor -> factorAux .)
    LOWERTHAN       reduce using rule 71 (factor -> factorAux .)
    MORETHAN        reduce using rule 71 (factor -> factorAux .)
    DIFFERENT       reduce using rule 71 (factor -> factorAux .)
    RPAREN          reduce using rule 71 (factor -> factorAux .)
    SEMICOLON       reduce using rule 71 (factor -> factorAux .)


state 70

    (72) factorAux -> PLUS . push_poper var_cte
    (77) push_poper -> .

    ID              reduce using rule 77 (push_poper -> .)
    CTE_I           reduce using rule 77 (push_poper -> .)
    CTE_F           reduce using rule 77 (push_poper -> .)

    push_poper                     shift and go to state 91

state 71

    (74) factorAux -> var_cte .

    TIMES           reduce using rule 74 (factorAux -> var_cte .)
    DIVIDE          reduce using rule 74 (factorAux -> var_cte .)
    PLUS            reduce using rule 74 (factorAux -> var_cte .)
    MINUS           reduce using rule 74 (factorAux -> var_cte .)
    LOWERTHAN       reduce using rule 74 (factorAux -> var_cte .)
    MORETHAN        reduce using rule 74 (factorAux -> var_cte .)
    DIFFERENT       reduce using rule 74 (factorAux -> var_cte .)
    RPAREN          reduce using rule 74 (factorAux -> var_cte .)
    SEMICOLON       reduce using rule 74 (factorAux -> var_cte .)


state 72

    (73) factorAux -> MINUS . push_poper var_cte
    (77) push_poper -> .

    ID              reduce using rule 77 (push_poper -> .)
    CTE_I           reduce using rule 77 (push_poper -> .)
    CTE_F           reduce using rule 77 (push_poper -> .)

    push_poper                     shift and go to state 92

state 73

    (78) var_cte -> ID . push_id
    (75) push_id -> .

    TIMES           reduce using rule 75 (push_id -> .)
    DIVIDE          reduce using rule 75 (push_id -> .)
    PLUS            reduce using rule 75 (push_id -> .)
    MINUS           reduce using rule 75 (push_id -> .)
    LOWERTHAN       reduce using rule 75 (push_id -> .)
    MORETHAN        reduce using rule 75 (push_id -> .)
    DIFFERENT       reduce using rule 75 (push_id -> .)
    RPAREN          reduce using rule 75 (push_id -> .)
    SEMICOLON       reduce using rule 75 (push_id -> .)

    push_id                        shift and go to state 93

state 74

    (79) var_cte -> CTE_I . push_cte
    (76) push_cte -> .

    TIMES           reduce using rule 76 (push_cte -> .)
    DIVIDE          reduce using rule 76 (push_cte -> .)
    PLUS            reduce using rule 76 (push_cte -> .)
    MINUS           reduce using rule 76 (push_cte -> .)
    LOWERTHAN       reduce using rule 76 (push_cte -> .)
    MORETHAN        reduce using rule 76 (push_cte -> .)
    DIFFERENT       reduce using rule 76 (push_cte -> .)
    RPAREN          reduce using rule 76 (push_cte -> .)
    SEMICOLON       reduce using rule 76 (push_cte -> .)

    push_cte                       shift and go to state 94

state 75

    (80) var_cte -> CTE_F . push_cte
    (76) push_cte -> .

    TIMES           reduce using rule 76 (push_cte -> .)
    DIVIDE          reduce using rule 76 (push_cte -> .)
    PLUS            reduce using rule 76 (push_cte -> .)
    MINUS           reduce using rule 76 (push_cte -> .)
    LOWERTHAN       reduce using rule 76 (push_cte -> .)
    MORETHAN        reduce using rule 76 (push_cte -> .)
    DIFFERENT       reduce using rule 76 (push_cte -> .)
    RPAREN          reduce using rule 76 (push_cte -> .)
    SEMICOLON       reduce using rule 76 (push_cte -> .)

    push_cte                       shift and go to state 95

state 76

    (49) escritura -> PRINT push_poper LPAREN . exp RPAREN quad_print SEMICOLON
    (60) exp -> . termino quad_term
    (61) exp -> . termino quad_term exp1
    (66) termino -> . factor quad_fact
    (67) termino -> . factor quad_fact termino1
    (70) factor -> . LPAREN expresion RPAREN
    (71) factor -> . factorAux
    (72) factorAux -> . PLUS push_poper var_cte
    (73) factorAux -> . MINUS push_poper var_cte
    (74) factorAux -> . var_cte
    (78) var_cte -> . ID push_id
    (79) var_cte -> . CTE_I push_cte
    (80) var_cte -> . CTE_F push_cte

    LPAREN          shift and go to state 64
    PLUS            shift and go to state 70
    MINUS           shift and go to state 72
    ID              shift and go to state 73
    CTE_I           shift and go to state 74
    CTE_F           shift and go to state 75

    exp                            shift and go to state 96
    termino                        shift and go to state 67
    factor                         shift and go to state 68
    factorAux                      shift and go to state 69
    var_cte                        shift and go to state 71

state 77

    (35) while -> WHILE LPAREN expresion . RPAREN bloque

    RPAREN          shift and go to state 97


state 78

    (22) function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE .
    (24) function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE . function
    (22) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE
    (23) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE
    (24) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE function
    (25) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE function
    (26) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE
    (27) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE
    (28) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE function
    (29) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE function

    $end            reduce using rule 22 (function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE .)
    FUNCTION        shift and go to state 12

    function                       shift and go to state 98

state 79

    (23) function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars . bloqueAux RBRACE
    (25) function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars . bloqueAux RBRACE function
    (33) bloqueAux -> . estatuto
    (34) bloqueAux -> . estatuto bloqueAux
    (36) estatuto -> . asignacion
    (37) estatuto -> . condicion
    (38) estatuto -> . escritura
    (39) estatuto -> . while
    (40) estatuto -> . comparacion
    (41) asignacion -> . ID push_id EQUAL push_poper expresion create_asign SEMICOLON
    (44) condicion -> . IF LPAREN expresion RPAREN cond bloque SEMICOLON condFinal
    (45) condicion -> . IF LPAREN expresion RPAREN cond bloque ELSE condElse bloque SEMICOLON condFinal
    (49) escritura -> . PRINT push_poper LPAREN exp RPAREN quad_print SEMICOLON
    (35) while -> . WHILE LPAREN expresion RPAREN bloque
    (43) comparacion -> . ID push_id DOUBLEEQUAL push_poper expresion SEMICOLON

    ID              shift and go to state 44
    IF              shift and go to state 45
    PRINT           shift and go to state 46
    WHILE           shift and go to state 47

    bloqueAux                      shift and go to state 99
    estatuto                       shift and go to state 38
    asignacion                     shift and go to state 39
    condicion                      shift and go to state 40
    escritura                      shift and go to state 41
    while                          shift and go to state 42
    comparacion                    shift and go to state 43

state 80

    (26) function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE . RBRACE
    (27) function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE . vars bloqueAux RBRACE
    (28) function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE . RBRACE function
    (29) function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE . vars bloqueAux RBRACE function
    (8) vars -> . VAR varAux1

    RBRACE          shift and go to state 100
    VAR             shift and go to state 7

    vars                           shift and go to state 101

state 81

    (31) param -> tipo ID COMA . param
    (30) param -> . tipo ID
    (31) param -> . tipo ID COMA param
    (13) tipo -> . INT
    (14) tipo -> . FLOAT
    (15) tipo -> . CHAR

    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17

    tipo                           shift and go to state 50
    param                          shift and go to state 102

state 82

    (41) asignacion -> ID push_id EQUAL push_poper . expresion create_asign SEMICOLON
    (55) expresion -> . exp
    (56) expresion -> . exp LOWERTHAN push_poper exp quad_comp
    (57) expresion -> . exp MORETHAN push_poper exp quad_comp
    (58) expresion -> . exp DIFFERENT push_poper exp quad_comp
    (60) exp -> . termino quad_term
    (61) exp -> . termino quad_term exp1
    (66) termino -> . factor quad_fact
    (67) termino -> . factor quad_fact termino1
    (70) factor -> . LPAREN expresion RPAREN
    (71) factor -> . factorAux
    (72) factorAux -> . PLUS push_poper var_cte
    (73) factorAux -> . MINUS push_poper var_cte
    (74) factorAux -> . var_cte
    (78) var_cte -> . ID push_id
    (79) var_cte -> . CTE_I push_cte
    (80) var_cte -> . CTE_F push_cte

    LPAREN          shift and go to state 64
    PLUS            shift and go to state 70
    MINUS           shift and go to state 72
    ID              shift and go to state 73
    CTE_I           shift and go to state 74
    CTE_F           shift and go to state 75

    expresion                      shift and go to state 103
    exp                            shift and go to state 66
    termino                        shift and go to state 67
    factor                         shift and go to state 68
    factorAux                      shift and go to state 69
    var_cte                        shift and go to state 71

state 83

    (43) comparacion -> ID push_id DOUBLEEQUAL push_poper . expresion SEMICOLON
    (55) expresion -> . exp
    (56) expresion -> . exp LOWERTHAN push_poper exp quad_comp
    (57) expresion -> . exp MORETHAN push_poper exp quad_comp
    (58) expresion -> . exp DIFFERENT push_poper exp quad_comp
    (60) exp -> . termino quad_term
    (61) exp -> . termino quad_term exp1
    (66) termino -> . factor quad_fact
    (67) termino -> . factor quad_fact termino1
    (70) factor -> . LPAREN expresion RPAREN
    (71) factor -> . factorAux
    (72) factorAux -> . PLUS push_poper var_cte
    (73) factorAux -> . MINUS push_poper var_cte
    (74) factorAux -> . var_cte
    (78) var_cte -> . ID push_id
    (79) var_cte -> . CTE_I push_cte
    (80) var_cte -> . CTE_F push_cte

    LPAREN          shift and go to state 64
    PLUS            shift and go to state 70
    MINUS           shift and go to state 72
    ID              shift and go to state 73
    CTE_I           shift and go to state 74
    CTE_F           shift and go to state 75

    expresion                      shift and go to state 104
    exp                            shift and go to state 66
    termino                        shift and go to state 67
    factor                         shift and go to state 68
    factorAux                      shift and go to state 69
    var_cte                        shift and go to state 71

state 84

    (70) factor -> LPAREN expresion . RPAREN

    RPAREN          shift and go to state 105


state 85

    (44) condicion -> IF LPAREN expresion RPAREN . cond bloque SEMICOLON condFinal
    (45) condicion -> IF LPAREN expresion RPAREN . cond bloque ELSE condElse bloque SEMICOLON condFinal
    (46) cond -> .

    LBRACE          reduce using rule 46 (cond -> .)

    cond                           shift and go to state 106

state 86

    (56) expresion -> exp LOWERTHAN . push_poper exp quad_comp
    (77) push_poper -> .

    LPAREN          reduce using rule 77 (push_poper -> .)
    PLUS            reduce using rule 77 (push_poper -> .)
    MINUS           reduce using rule 77 (push_poper -> .)
    ID              reduce using rule 77 (push_poper -> .)
    CTE_I           reduce using rule 77 (push_poper -> .)
    CTE_F           reduce using rule 77 (push_poper -> .)

    push_poper                     shift and go to state 107

state 87

    (57) expresion -> exp MORETHAN . push_poper exp quad_comp
    (77) push_poper -> .

    LPAREN          reduce using rule 77 (push_poper -> .)
    PLUS            reduce using rule 77 (push_poper -> .)
    MINUS           reduce using rule 77 (push_poper -> .)
    ID              reduce using rule 77 (push_poper -> .)
    CTE_I           reduce using rule 77 (push_poper -> .)
    CTE_F           reduce using rule 77 (push_poper -> .)

    push_poper                     shift and go to state 108

state 88

    (58) expresion -> exp DIFFERENT . push_poper exp quad_comp
    (77) push_poper -> .

    LPAREN          reduce using rule 77 (push_poper -> .)
    PLUS            reduce using rule 77 (push_poper -> .)
    MINUS           reduce using rule 77 (push_poper -> .)
    ID              reduce using rule 77 (push_poper -> .)
    CTE_I           reduce using rule 77 (push_poper -> .)
    CTE_F           reduce using rule 77 (push_poper -> .)

    push_poper                     shift and go to state 109

state 89

    (60) exp -> termino quad_term .
    (61) exp -> termino quad_term . exp1
    (62) exp1 -> . PLUS push_poper exp
    (63) exp1 -> . MINUS push_poper exp

    LOWERTHAN       reduce using rule 60 (exp -> termino quad_term .)
    MORETHAN        reduce using rule 60 (exp -> termino quad_term .)
    DIFFERENT       reduce using rule 60 (exp -> termino quad_term .)
    RPAREN          reduce using rule 60 (exp -> termino quad_term .)
    SEMICOLON       reduce using rule 60 (exp -> termino quad_term .)
    PLUS            shift and go to state 111
    MINUS           shift and go to state 112

    exp1                           shift and go to state 110

state 90

    (66) termino -> factor quad_fact .
    (67) termino -> factor quad_fact . termino1
    (68) termino1 -> . TIMES push_poper termino
    (69) termino1 -> . DIVIDE push_poper termino

    PLUS            reduce using rule 66 (termino -> factor quad_fact .)
    MINUS           reduce using rule 66 (termino -> factor quad_fact .)
    LOWERTHAN       reduce using rule 66 (termino -> factor quad_fact .)
    MORETHAN        reduce using rule 66 (termino -> factor quad_fact .)
    DIFFERENT       reduce using rule 66 (termino -> factor quad_fact .)
    RPAREN          reduce using rule 66 (termino -> factor quad_fact .)
    SEMICOLON       reduce using rule 66 (termino -> factor quad_fact .)
    TIMES           shift and go to state 114
    DIVIDE          shift and go to state 115

    termino1                       shift and go to state 113

state 91

    (72) factorAux -> PLUS push_poper . var_cte
    (78) var_cte -> . ID push_id
    (79) var_cte -> . CTE_I push_cte
    (80) var_cte -> . CTE_F push_cte

    ID              shift and go to state 73
    CTE_I           shift and go to state 74
    CTE_F           shift and go to state 75

    var_cte                        shift and go to state 116

state 92

    (73) factorAux -> MINUS push_poper . var_cte
    (78) var_cte -> . ID push_id
    (79) var_cte -> . CTE_I push_cte
    (80) var_cte -> . CTE_F push_cte

    ID              shift and go to state 73
    CTE_I           shift and go to state 74
    CTE_F           shift and go to state 75

    var_cte                        shift and go to state 117

state 93

    (78) var_cte -> ID push_id .

    TIMES           reduce using rule 78 (var_cte -> ID push_id .)
    DIVIDE          reduce using rule 78 (var_cte -> ID push_id .)
    PLUS            reduce using rule 78 (var_cte -> ID push_id .)
    MINUS           reduce using rule 78 (var_cte -> ID push_id .)
    LOWERTHAN       reduce using rule 78 (var_cte -> ID push_id .)
    MORETHAN        reduce using rule 78 (var_cte -> ID push_id .)
    DIFFERENT       reduce using rule 78 (var_cte -> ID push_id .)
    RPAREN          reduce using rule 78 (var_cte -> ID push_id .)
    SEMICOLON       reduce using rule 78 (var_cte -> ID push_id .)


state 94

    (79) var_cte -> CTE_I push_cte .

    TIMES           reduce using rule 79 (var_cte -> CTE_I push_cte .)
    DIVIDE          reduce using rule 79 (var_cte -> CTE_I push_cte .)
    PLUS            reduce using rule 79 (var_cte -> CTE_I push_cte .)
    MINUS           reduce using rule 79 (var_cte -> CTE_I push_cte .)
    LOWERTHAN       reduce using rule 79 (var_cte -> CTE_I push_cte .)
    MORETHAN        reduce using rule 79 (var_cte -> CTE_I push_cte .)
    DIFFERENT       reduce using rule 79 (var_cte -> CTE_I push_cte .)
    RPAREN          reduce using rule 79 (var_cte -> CTE_I push_cte .)
    SEMICOLON       reduce using rule 79 (var_cte -> CTE_I push_cte .)


state 95

    (80) var_cte -> CTE_F push_cte .

    TIMES           reduce using rule 80 (var_cte -> CTE_F push_cte .)
    DIVIDE          reduce using rule 80 (var_cte -> CTE_F push_cte .)
    PLUS            reduce using rule 80 (var_cte -> CTE_F push_cte .)
    MINUS           reduce using rule 80 (var_cte -> CTE_F push_cte .)
    LOWERTHAN       reduce using rule 80 (var_cte -> CTE_F push_cte .)
    MORETHAN        reduce using rule 80 (var_cte -> CTE_F push_cte .)
    DIFFERENT       reduce using rule 80 (var_cte -> CTE_F push_cte .)
    RPAREN          reduce using rule 80 (var_cte -> CTE_F push_cte .)
    SEMICOLON       reduce using rule 80 (var_cte -> CTE_F push_cte .)


state 96

    (49) escritura -> PRINT push_poper LPAREN exp . RPAREN quad_print SEMICOLON

    RPAREN          shift and go to state 118


state 97

    (35) while -> WHILE LPAREN expresion RPAREN . bloque
    (20) bloque -> . LBRACE RBRACE
    (21) bloque -> . LBRACE bloqueAux RBRACE

    LBRACE          shift and go to state 120

    bloque                         shift and go to state 119

state 98

    (24) function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE function .

    $end            reduce using rule 24 (function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE function .)


state 99

    (23) function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux . RBRACE
    (25) function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux . RBRACE function

    RBRACE          shift and go to state 121


state 100

    (26) function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE .
    (28) function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE . function
    (22) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE
    (23) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE
    (24) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE function
    (25) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE function
    (26) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE
    (27) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE
    (28) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE function
    (29) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE function

    $end            reduce using rule 26 (function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE .)
    FUNCTION        shift and go to state 12

    function                       shift and go to state 122

state 101

    (27) function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars . bloqueAux RBRACE
    (29) function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars . bloqueAux RBRACE function
    (33) bloqueAux -> . estatuto
    (34) bloqueAux -> . estatuto bloqueAux
    (36) estatuto -> . asignacion
    (37) estatuto -> . condicion
    (38) estatuto -> . escritura
    (39) estatuto -> . while
    (40) estatuto -> . comparacion
    (41) asignacion -> . ID push_id EQUAL push_poper expresion create_asign SEMICOLON
    (44) condicion -> . IF LPAREN expresion RPAREN cond bloque SEMICOLON condFinal
    (45) condicion -> . IF LPAREN expresion RPAREN cond bloque ELSE condElse bloque SEMICOLON condFinal
    (49) escritura -> . PRINT push_poper LPAREN exp RPAREN quad_print SEMICOLON
    (35) while -> . WHILE LPAREN expresion RPAREN bloque
    (43) comparacion -> . ID push_id DOUBLEEQUAL push_poper expresion SEMICOLON

    ID              shift and go to state 44
    IF              shift and go to state 45
    PRINT           shift and go to state 46
    WHILE           shift and go to state 47

    bloqueAux                      shift and go to state 123
    estatuto                       shift and go to state 38
    asignacion                     shift and go to state 39
    condicion                      shift and go to state 40
    escritura                      shift and go to state 41
    while                          shift and go to state 42
    comparacion                    shift and go to state 43

state 102

    (31) param -> tipo ID COMA param .

    RPAREN          reduce using rule 31 (param -> tipo ID COMA param .)


state 103

    (41) asignacion -> ID push_id EQUAL push_poper expresion . create_asign SEMICOLON
    (42) create_asign -> .

    SEMICOLON       reduce using rule 42 (create_asign -> .)

    create_asign                   shift and go to state 124

state 104

    (43) comparacion -> ID push_id DOUBLEEQUAL push_poper expresion . SEMICOLON

    SEMICOLON       shift and go to state 125


state 105

    (70) factor -> LPAREN expresion RPAREN .

    TIMES           reduce using rule 70 (factor -> LPAREN expresion RPAREN .)
    DIVIDE          reduce using rule 70 (factor -> LPAREN expresion RPAREN .)
    PLUS            reduce using rule 70 (factor -> LPAREN expresion RPAREN .)
    MINUS           reduce using rule 70 (factor -> LPAREN expresion RPAREN .)
    LOWERTHAN       reduce using rule 70 (factor -> LPAREN expresion RPAREN .)
    MORETHAN        reduce using rule 70 (factor -> LPAREN expresion RPAREN .)
    DIFFERENT       reduce using rule 70 (factor -> LPAREN expresion RPAREN .)
    RPAREN          reduce using rule 70 (factor -> LPAREN expresion RPAREN .)
    SEMICOLON       reduce using rule 70 (factor -> LPAREN expresion RPAREN .)


state 106

    (44) condicion -> IF LPAREN expresion RPAREN cond . bloque SEMICOLON condFinal
    (45) condicion -> IF LPAREN expresion RPAREN cond . bloque ELSE condElse bloque SEMICOLON condFinal
    (20) bloque -> . LBRACE RBRACE
    (21) bloque -> . LBRACE bloqueAux RBRACE

    LBRACE          shift and go to state 120

    bloque                         shift and go to state 126

state 107

    (56) expresion -> exp LOWERTHAN push_poper . exp quad_comp
    (60) exp -> . termino quad_term
    (61) exp -> . termino quad_term exp1
    (66) termino -> . factor quad_fact
    (67) termino -> . factor quad_fact termino1
    (70) factor -> . LPAREN expresion RPAREN
    (71) factor -> . factorAux
    (72) factorAux -> . PLUS push_poper var_cte
    (73) factorAux -> . MINUS push_poper var_cte
    (74) factorAux -> . var_cte
    (78) var_cte -> . ID push_id
    (79) var_cte -> . CTE_I push_cte
    (80) var_cte -> . CTE_F push_cte

    LPAREN          shift and go to state 64
    PLUS            shift and go to state 70
    MINUS           shift and go to state 72
    ID              shift and go to state 73
    CTE_I           shift and go to state 74
    CTE_F           shift and go to state 75

    exp                            shift and go to state 127
    termino                        shift and go to state 67
    factor                         shift and go to state 68
    factorAux                      shift and go to state 69
    var_cte                        shift and go to state 71

state 108

    (57) expresion -> exp MORETHAN push_poper . exp quad_comp
    (60) exp -> . termino quad_term
    (61) exp -> . termino quad_term exp1
    (66) termino -> . factor quad_fact
    (67) termino -> . factor quad_fact termino1
    (70) factor -> . LPAREN expresion RPAREN
    (71) factor -> . factorAux
    (72) factorAux -> . PLUS push_poper var_cte
    (73) factorAux -> . MINUS push_poper var_cte
    (74) factorAux -> . var_cte
    (78) var_cte -> . ID push_id
    (79) var_cte -> . CTE_I push_cte
    (80) var_cte -> . CTE_F push_cte

    LPAREN          shift and go to state 64
    PLUS            shift and go to state 70
    MINUS           shift and go to state 72
    ID              shift and go to state 73
    CTE_I           shift and go to state 74
    CTE_F           shift and go to state 75

    exp                            shift and go to state 128
    termino                        shift and go to state 67
    factor                         shift and go to state 68
    factorAux                      shift and go to state 69
    var_cte                        shift and go to state 71

state 109

    (58) expresion -> exp DIFFERENT push_poper . exp quad_comp
    (60) exp -> . termino quad_term
    (61) exp -> . termino quad_term exp1
    (66) termino -> . factor quad_fact
    (67) termino -> . factor quad_fact termino1
    (70) factor -> . LPAREN expresion RPAREN
    (71) factor -> . factorAux
    (72) factorAux -> . PLUS push_poper var_cte
    (73) factorAux -> . MINUS push_poper var_cte
    (74) factorAux -> . var_cte
    (78) var_cte -> . ID push_id
    (79) var_cte -> . CTE_I push_cte
    (80) var_cte -> . CTE_F push_cte

    LPAREN          shift and go to state 64
    PLUS            shift and go to state 70
    MINUS           shift and go to state 72
    ID              shift and go to state 73
    CTE_I           shift and go to state 74
    CTE_F           shift and go to state 75

    exp                            shift and go to state 129
    termino                        shift and go to state 67
    factor                         shift and go to state 68
    factorAux                      shift and go to state 69
    var_cte                        shift and go to state 71

state 110

    (61) exp -> termino quad_term exp1 .

    LOWERTHAN       reduce using rule 61 (exp -> termino quad_term exp1 .)
    MORETHAN        reduce using rule 61 (exp -> termino quad_term exp1 .)
    DIFFERENT       reduce using rule 61 (exp -> termino quad_term exp1 .)
    RPAREN          reduce using rule 61 (exp -> termino quad_term exp1 .)
    SEMICOLON       reduce using rule 61 (exp -> termino quad_term exp1 .)


state 111

    (62) exp1 -> PLUS . push_poper exp
    (77) push_poper -> .

    LPAREN          reduce using rule 77 (push_poper -> .)
    PLUS            reduce using rule 77 (push_poper -> .)
    MINUS           reduce using rule 77 (push_poper -> .)
    ID              reduce using rule 77 (push_poper -> .)
    CTE_I           reduce using rule 77 (push_poper -> .)
    CTE_F           reduce using rule 77 (push_poper -> .)

    push_poper                     shift and go to state 130

state 112

    (63) exp1 -> MINUS . push_poper exp
    (77) push_poper -> .

    LPAREN          reduce using rule 77 (push_poper -> .)
    PLUS            reduce using rule 77 (push_poper -> .)
    MINUS           reduce using rule 77 (push_poper -> .)
    ID              reduce using rule 77 (push_poper -> .)
    CTE_I           reduce using rule 77 (push_poper -> .)
    CTE_F           reduce using rule 77 (push_poper -> .)

    push_poper                     shift and go to state 131

state 113

    (67) termino -> factor quad_fact termino1 .

    PLUS            reduce using rule 67 (termino -> factor quad_fact termino1 .)
    MINUS           reduce using rule 67 (termino -> factor quad_fact termino1 .)
    LOWERTHAN       reduce using rule 67 (termino -> factor quad_fact termino1 .)
    MORETHAN        reduce using rule 67 (termino -> factor quad_fact termino1 .)
    DIFFERENT       reduce using rule 67 (termino -> factor quad_fact termino1 .)
    RPAREN          reduce using rule 67 (termino -> factor quad_fact termino1 .)
    SEMICOLON       reduce using rule 67 (termino -> factor quad_fact termino1 .)


state 114

    (68) termino1 -> TIMES . push_poper termino
    (77) push_poper -> .

    LPAREN          reduce using rule 77 (push_poper -> .)
    PLUS            reduce using rule 77 (push_poper -> .)
    MINUS           reduce using rule 77 (push_poper -> .)
    ID              reduce using rule 77 (push_poper -> .)
    CTE_I           reduce using rule 77 (push_poper -> .)
    CTE_F           reduce using rule 77 (push_poper -> .)

    push_poper                     shift and go to state 132

state 115

    (69) termino1 -> DIVIDE . push_poper termino
    (77) push_poper -> .

    LPAREN          reduce using rule 77 (push_poper -> .)
    PLUS            reduce using rule 77 (push_poper -> .)
    MINUS           reduce using rule 77 (push_poper -> .)
    ID              reduce using rule 77 (push_poper -> .)
    CTE_I           reduce using rule 77 (push_poper -> .)
    CTE_F           reduce using rule 77 (push_poper -> .)

    push_poper                     shift and go to state 133

state 116

    (72) factorAux -> PLUS push_poper var_cte .

    TIMES           reduce using rule 72 (factorAux -> PLUS push_poper var_cte .)
    DIVIDE          reduce using rule 72 (factorAux -> PLUS push_poper var_cte .)
    PLUS            reduce using rule 72 (factorAux -> PLUS push_poper var_cte .)
    MINUS           reduce using rule 72 (factorAux -> PLUS push_poper var_cte .)
    LOWERTHAN       reduce using rule 72 (factorAux -> PLUS push_poper var_cte .)
    MORETHAN        reduce using rule 72 (factorAux -> PLUS push_poper var_cte .)
    DIFFERENT       reduce using rule 72 (factorAux -> PLUS push_poper var_cte .)
    RPAREN          reduce using rule 72 (factorAux -> PLUS push_poper var_cte .)
    SEMICOLON       reduce using rule 72 (factorAux -> PLUS push_poper var_cte .)


state 117

    (73) factorAux -> MINUS push_poper var_cte .

    TIMES           reduce using rule 73 (factorAux -> MINUS push_poper var_cte .)
    DIVIDE          reduce using rule 73 (factorAux -> MINUS push_poper var_cte .)
    PLUS            reduce using rule 73 (factorAux -> MINUS push_poper var_cte .)
    MINUS           reduce using rule 73 (factorAux -> MINUS push_poper var_cte .)
    LOWERTHAN       reduce using rule 73 (factorAux -> MINUS push_poper var_cte .)
    MORETHAN        reduce using rule 73 (factorAux -> MINUS push_poper var_cte .)
    DIFFERENT       reduce using rule 73 (factorAux -> MINUS push_poper var_cte .)
    RPAREN          reduce using rule 73 (factorAux -> MINUS push_poper var_cte .)
    SEMICOLON       reduce using rule 73 (factorAux -> MINUS push_poper var_cte .)


state 118

    (49) escritura -> PRINT push_poper LPAREN exp RPAREN . quad_print SEMICOLON
    (50) quad_print -> .

    SEMICOLON       reduce using rule 50 (quad_print -> .)

    quad_print                     shift and go to state 134

state 119

    (35) while -> WHILE LPAREN expresion RPAREN bloque .

    ID              reduce using rule 35 (while -> WHILE LPAREN expresion RPAREN bloque .)
    IF              reduce using rule 35 (while -> WHILE LPAREN expresion RPAREN bloque .)
    PRINT           reduce using rule 35 (while -> WHILE LPAREN expresion RPAREN bloque .)
    WHILE           reduce using rule 35 (while -> WHILE LPAREN expresion RPAREN bloque .)
    RBRACE          reduce using rule 35 (while -> WHILE LPAREN expresion RPAREN bloque .)


state 120

    (20) bloque -> LBRACE . RBRACE
    (21) bloque -> LBRACE . bloqueAux RBRACE
    (33) bloqueAux -> . estatuto
    (34) bloqueAux -> . estatuto bloqueAux
    (36) estatuto -> . asignacion
    (37) estatuto -> . condicion
    (38) estatuto -> . escritura
    (39) estatuto -> . while
    (40) estatuto -> . comparacion
    (41) asignacion -> . ID push_id EQUAL push_poper expresion create_asign SEMICOLON
    (44) condicion -> . IF LPAREN expresion RPAREN cond bloque SEMICOLON condFinal
    (45) condicion -> . IF LPAREN expresion RPAREN cond bloque ELSE condElse bloque SEMICOLON condFinal
    (49) escritura -> . PRINT push_poper LPAREN exp RPAREN quad_print SEMICOLON
    (35) while -> . WHILE LPAREN expresion RPAREN bloque
    (43) comparacion -> . ID push_id DOUBLEEQUAL push_poper expresion SEMICOLON

    RBRACE          shift and go to state 135
    ID              shift and go to state 44
    IF              shift and go to state 45
    PRINT           shift and go to state 46
    WHILE           shift and go to state 47

    bloqueAux                      shift and go to state 136
    estatuto                       shift and go to state 38
    asignacion                     shift and go to state 39
    condicion                      shift and go to state 40
    escritura                      shift and go to state 41
    while                          shift and go to state 42
    comparacion                    shift and go to state 43

state 121

    (23) function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE .
    (25) function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE . function
    (22) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE
    (23) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE
    (24) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE function
    (25) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE function
    (26) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE
    (27) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE
    (28) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE function
    (29) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE function

    $end            reduce using rule 23 (function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE .)
    FUNCTION        shift and go to state 12

    function                       shift and go to state 137

state 122

    (28) function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE function .

    $end            reduce using rule 28 (function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE function .)


state 123

    (27) function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux . RBRACE
    (29) function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux . RBRACE function

    RBRACE          shift and go to state 138


state 124

    (41) asignacion -> ID push_id EQUAL push_poper expresion create_asign . SEMICOLON

    SEMICOLON       shift and go to state 139


state 125

    (43) comparacion -> ID push_id DOUBLEEQUAL push_poper expresion SEMICOLON .

    ID              reduce using rule 43 (comparacion -> ID push_id DOUBLEEQUAL push_poper expresion SEMICOLON .)
    IF              reduce using rule 43 (comparacion -> ID push_id DOUBLEEQUAL push_poper expresion SEMICOLON .)
    PRINT           reduce using rule 43 (comparacion -> ID push_id DOUBLEEQUAL push_poper expresion SEMICOLON .)
    WHILE           reduce using rule 43 (comparacion -> ID push_id DOUBLEEQUAL push_poper expresion SEMICOLON .)
    RBRACE          reduce using rule 43 (comparacion -> ID push_id DOUBLEEQUAL push_poper expresion SEMICOLON .)


state 126

    (44) condicion -> IF LPAREN expresion RPAREN cond bloque . SEMICOLON condFinal
    (45) condicion -> IF LPAREN expresion RPAREN cond bloque . ELSE condElse bloque SEMICOLON condFinal

    SEMICOLON       shift and go to state 140
    ELSE            shift and go to state 141


state 127

    (56) expresion -> exp LOWERTHAN push_poper exp . quad_comp
    (59) quad_comp -> .

    RPAREN          reduce using rule 59 (quad_comp -> .)
    SEMICOLON       reduce using rule 59 (quad_comp -> .)

    quad_comp                      shift and go to state 142

state 128

    (57) expresion -> exp MORETHAN push_poper exp . quad_comp
    (59) quad_comp -> .

    RPAREN          reduce using rule 59 (quad_comp -> .)
    SEMICOLON       reduce using rule 59 (quad_comp -> .)

    quad_comp                      shift and go to state 143

state 129

    (58) expresion -> exp DIFFERENT push_poper exp . quad_comp
    (59) quad_comp -> .

    RPAREN          reduce using rule 59 (quad_comp -> .)
    SEMICOLON       reduce using rule 59 (quad_comp -> .)

    quad_comp                      shift and go to state 144

state 130

    (62) exp1 -> PLUS push_poper . exp
    (60) exp -> . termino quad_term
    (61) exp -> . termino quad_term exp1
    (66) termino -> . factor quad_fact
    (67) termino -> . factor quad_fact termino1
    (70) factor -> . LPAREN expresion RPAREN
    (71) factor -> . factorAux
    (72) factorAux -> . PLUS push_poper var_cte
    (73) factorAux -> . MINUS push_poper var_cte
    (74) factorAux -> . var_cte
    (78) var_cte -> . ID push_id
    (79) var_cte -> . CTE_I push_cte
    (80) var_cte -> . CTE_F push_cte

    LPAREN          shift and go to state 64
    PLUS            shift and go to state 70
    MINUS           shift and go to state 72
    ID              shift and go to state 73
    CTE_I           shift and go to state 74
    CTE_F           shift and go to state 75

    exp                            shift and go to state 145
    termino                        shift and go to state 67
    factor                         shift and go to state 68
    factorAux                      shift and go to state 69
    var_cte                        shift and go to state 71

state 131

    (63) exp1 -> MINUS push_poper . exp
    (60) exp -> . termino quad_term
    (61) exp -> . termino quad_term exp1
    (66) termino -> . factor quad_fact
    (67) termino -> . factor quad_fact termino1
    (70) factor -> . LPAREN expresion RPAREN
    (71) factor -> . factorAux
    (72) factorAux -> . PLUS push_poper var_cte
    (73) factorAux -> . MINUS push_poper var_cte
    (74) factorAux -> . var_cte
    (78) var_cte -> . ID push_id
    (79) var_cte -> . CTE_I push_cte
    (80) var_cte -> . CTE_F push_cte

    LPAREN          shift and go to state 64
    PLUS            shift and go to state 70
    MINUS           shift and go to state 72
    ID              shift and go to state 73
    CTE_I           shift and go to state 74
    CTE_F           shift and go to state 75

    exp                            shift and go to state 146
    termino                        shift and go to state 67
    factor                         shift and go to state 68
    factorAux                      shift and go to state 69
    var_cte                        shift and go to state 71

state 132

    (68) termino1 -> TIMES push_poper . termino
    (66) termino -> . factor quad_fact
    (67) termino -> . factor quad_fact termino1
    (70) factor -> . LPAREN expresion RPAREN
    (71) factor -> . factorAux
    (72) factorAux -> . PLUS push_poper var_cte
    (73) factorAux -> . MINUS push_poper var_cte
    (74) factorAux -> . var_cte
    (78) var_cte -> . ID push_id
    (79) var_cte -> . CTE_I push_cte
    (80) var_cte -> . CTE_F push_cte

    LPAREN          shift and go to state 64
    PLUS            shift and go to state 70
    MINUS           shift and go to state 72
    ID              shift and go to state 73
    CTE_I           shift and go to state 74
    CTE_F           shift and go to state 75

    termino                        shift and go to state 147
    factor                         shift and go to state 68
    factorAux                      shift and go to state 69
    var_cte                        shift and go to state 71

state 133

    (69) termino1 -> DIVIDE push_poper . termino
    (66) termino -> . factor quad_fact
    (67) termino -> . factor quad_fact termino1
    (70) factor -> . LPAREN expresion RPAREN
    (71) factor -> . factorAux
    (72) factorAux -> . PLUS push_poper var_cte
    (73) factorAux -> . MINUS push_poper var_cte
    (74) factorAux -> . var_cte
    (78) var_cte -> . ID push_id
    (79) var_cte -> . CTE_I push_cte
    (80) var_cte -> . CTE_F push_cte

    LPAREN          shift and go to state 64
    PLUS            shift and go to state 70
    MINUS           shift and go to state 72
    ID              shift and go to state 73
    CTE_I           shift and go to state 74
    CTE_F           shift and go to state 75

    termino                        shift and go to state 148
    factor                         shift and go to state 68
    factorAux                      shift and go to state 69
    var_cte                        shift and go to state 71

state 134

    (49) escritura -> PRINT push_poper LPAREN exp RPAREN quad_print . SEMICOLON

    SEMICOLON       shift and go to state 149


state 135

    (20) bloque -> LBRACE RBRACE .

    ID              reduce using rule 20 (bloque -> LBRACE RBRACE .)
    IF              reduce using rule 20 (bloque -> LBRACE RBRACE .)
    PRINT           reduce using rule 20 (bloque -> LBRACE RBRACE .)
    WHILE           reduce using rule 20 (bloque -> LBRACE RBRACE .)
    RBRACE          reduce using rule 20 (bloque -> LBRACE RBRACE .)
    SEMICOLON       reduce using rule 20 (bloque -> LBRACE RBRACE .)
    ELSE            reduce using rule 20 (bloque -> LBRACE RBRACE .)


state 136

    (21) bloque -> LBRACE bloqueAux . RBRACE

    RBRACE          shift and go to state 150


state 137

    (25) function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE function .

    $end            reduce using rule 25 (function -> FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE function .)


state 138

    (27) function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE .
    (29) function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE . function
    (22) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE
    (23) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE
    (24) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE RBRACE function
    (25) function -> . FUNCTION tipoFunc nomFunc LPAREN RPAREN LBRACE vars bloqueAux RBRACE function
    (26) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE
    (27) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE
    (28) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE RBRACE function
    (29) function -> . FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE function

    $end            reduce using rule 27 (function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE .)
    FUNCTION        shift and go to state 12

    function                       shift and go to state 151

state 139

    (41) asignacion -> ID push_id EQUAL push_poper expresion create_asign SEMICOLON .

    ID              reduce using rule 41 (asignacion -> ID push_id EQUAL push_poper expresion create_asign SEMICOLON .)
    IF              reduce using rule 41 (asignacion -> ID push_id EQUAL push_poper expresion create_asign SEMICOLON .)
    PRINT           reduce using rule 41 (asignacion -> ID push_id EQUAL push_poper expresion create_asign SEMICOLON .)
    WHILE           reduce using rule 41 (asignacion -> ID push_id EQUAL push_poper expresion create_asign SEMICOLON .)
    RBRACE          reduce using rule 41 (asignacion -> ID push_id EQUAL push_poper expresion create_asign SEMICOLON .)


state 140

    (44) condicion -> IF LPAREN expresion RPAREN cond bloque SEMICOLON . condFinal
    (48) condFinal -> .

    ID              reduce using rule 48 (condFinal -> .)
    IF              reduce using rule 48 (condFinal -> .)
    PRINT           reduce using rule 48 (condFinal -> .)
    WHILE           reduce using rule 48 (condFinal -> .)
    RBRACE          reduce using rule 48 (condFinal -> .)

    condFinal                      shift and go to state 152

state 141

    (45) condicion -> IF LPAREN expresion RPAREN cond bloque ELSE . condElse bloque SEMICOLON condFinal
    (47) condElse -> .

    LBRACE          reduce using rule 47 (condElse -> .)

    condElse                       shift and go to state 153

state 142

    (56) expresion -> exp LOWERTHAN push_poper exp quad_comp .

    RPAREN          reduce using rule 56 (expresion -> exp LOWERTHAN push_poper exp quad_comp .)
    SEMICOLON       reduce using rule 56 (expresion -> exp LOWERTHAN push_poper exp quad_comp .)


state 143

    (57) expresion -> exp MORETHAN push_poper exp quad_comp .

    RPAREN          reduce using rule 57 (expresion -> exp MORETHAN push_poper exp quad_comp .)
    SEMICOLON       reduce using rule 57 (expresion -> exp MORETHAN push_poper exp quad_comp .)


state 144

    (58) expresion -> exp DIFFERENT push_poper exp quad_comp .

    RPAREN          reduce using rule 58 (expresion -> exp DIFFERENT push_poper exp quad_comp .)
    SEMICOLON       reduce using rule 58 (expresion -> exp DIFFERENT push_poper exp quad_comp .)


state 145

    (62) exp1 -> PLUS push_poper exp .

    LOWERTHAN       reduce using rule 62 (exp1 -> PLUS push_poper exp .)
    MORETHAN        reduce using rule 62 (exp1 -> PLUS push_poper exp .)
    DIFFERENT       reduce using rule 62 (exp1 -> PLUS push_poper exp .)
    RPAREN          reduce using rule 62 (exp1 -> PLUS push_poper exp .)
    SEMICOLON       reduce using rule 62 (exp1 -> PLUS push_poper exp .)


state 146

    (63) exp1 -> MINUS push_poper exp .

    LOWERTHAN       reduce using rule 63 (exp1 -> MINUS push_poper exp .)
    MORETHAN        reduce using rule 63 (exp1 -> MINUS push_poper exp .)
    DIFFERENT       reduce using rule 63 (exp1 -> MINUS push_poper exp .)
    RPAREN          reduce using rule 63 (exp1 -> MINUS push_poper exp .)
    SEMICOLON       reduce using rule 63 (exp1 -> MINUS push_poper exp .)


state 147

    (68) termino1 -> TIMES push_poper termino .

    PLUS            reduce using rule 68 (termino1 -> TIMES push_poper termino .)
    MINUS           reduce using rule 68 (termino1 -> TIMES push_poper termino .)
    LOWERTHAN       reduce using rule 68 (termino1 -> TIMES push_poper termino .)
    MORETHAN        reduce using rule 68 (termino1 -> TIMES push_poper termino .)
    DIFFERENT       reduce using rule 68 (termino1 -> TIMES push_poper termino .)
    RPAREN          reduce using rule 68 (termino1 -> TIMES push_poper termino .)
    SEMICOLON       reduce using rule 68 (termino1 -> TIMES push_poper termino .)


state 148

    (69) termino1 -> DIVIDE push_poper termino .

    PLUS            reduce using rule 69 (termino1 -> DIVIDE push_poper termino .)
    MINUS           reduce using rule 69 (termino1 -> DIVIDE push_poper termino .)
    LOWERTHAN       reduce using rule 69 (termino1 -> DIVIDE push_poper termino .)
    MORETHAN        reduce using rule 69 (termino1 -> DIVIDE push_poper termino .)
    DIFFERENT       reduce using rule 69 (termino1 -> DIVIDE push_poper termino .)
    RPAREN          reduce using rule 69 (termino1 -> DIVIDE push_poper termino .)
    SEMICOLON       reduce using rule 69 (termino1 -> DIVIDE push_poper termino .)


state 149

    (49) escritura -> PRINT push_poper LPAREN exp RPAREN quad_print SEMICOLON .

    ID              reduce using rule 49 (escritura -> PRINT push_poper LPAREN exp RPAREN quad_print SEMICOLON .)
    IF              reduce using rule 49 (escritura -> PRINT push_poper LPAREN exp RPAREN quad_print SEMICOLON .)
    PRINT           reduce using rule 49 (escritura -> PRINT push_poper LPAREN exp RPAREN quad_print SEMICOLON .)
    WHILE           reduce using rule 49 (escritura -> PRINT push_poper LPAREN exp RPAREN quad_print SEMICOLON .)
    RBRACE          reduce using rule 49 (escritura -> PRINT push_poper LPAREN exp RPAREN quad_print SEMICOLON .)


state 150

    (21) bloque -> LBRACE bloqueAux RBRACE .

    ID              reduce using rule 21 (bloque -> LBRACE bloqueAux RBRACE .)
    IF              reduce using rule 21 (bloque -> LBRACE bloqueAux RBRACE .)
    PRINT           reduce using rule 21 (bloque -> LBRACE bloqueAux RBRACE .)
    WHILE           reduce using rule 21 (bloque -> LBRACE bloqueAux RBRACE .)
    RBRACE          reduce using rule 21 (bloque -> LBRACE bloqueAux RBRACE .)
    SEMICOLON       reduce using rule 21 (bloque -> LBRACE bloqueAux RBRACE .)
    ELSE            reduce using rule 21 (bloque -> LBRACE bloqueAux RBRACE .)


state 151

    (29) function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE function .

    $end            reduce using rule 29 (function -> FUNCTION tipoFunc nomFunc LPAREN param RPAREN LBRACE vars bloqueAux RBRACE function .)


state 152

    (44) condicion -> IF LPAREN expresion RPAREN cond bloque SEMICOLON condFinal .

    ID              reduce using rule 44 (condicion -> IF LPAREN expresion RPAREN cond bloque SEMICOLON condFinal .)
    IF              reduce using rule 44 (condicion -> IF LPAREN expresion RPAREN cond bloque SEMICOLON condFinal .)
    PRINT           reduce using rule 44 (condicion -> IF LPAREN expresion RPAREN cond bloque SEMICOLON condFinal .)
    WHILE           reduce using rule 44 (condicion -> IF LPAREN expresion RPAREN cond bloque SEMICOLON condFinal .)
    RBRACE          reduce using rule 44 (condicion -> IF LPAREN expresion RPAREN cond bloque SEMICOLON condFinal .)


state 153

    (45) condicion -> IF LPAREN expresion RPAREN cond bloque ELSE condElse . bloque SEMICOLON condFinal
    (20) bloque -> . LBRACE RBRACE
    (21) bloque -> . LBRACE bloqueAux RBRACE

    LBRACE          shift and go to state 120

    bloque                         shift and go to state 154

state 154

    (45) condicion -> IF LPAREN expresion RPAREN cond bloque ELSE condElse bloque . SEMICOLON condFinal

    SEMICOLON       shift and go to state 155


state 155

    (45) condicion -> IF LPAREN expresion RPAREN cond bloque ELSE condElse bloque SEMICOLON . condFinal
    (48) condFinal -> .

    ID              reduce using rule 48 (condFinal -> .)
    IF              reduce using rule 48 (condFinal -> .)
    PRINT           reduce using rule 48 (condFinal -> .)
    WHILE           reduce using rule 48 (condFinal -> .)
    RBRACE          reduce using rule 48 (condFinal -> .)

    condFinal                      shift and go to state 156

state 156

    (45) condicion -> IF LPAREN expresion RPAREN cond bloque ELSE condElse bloque SEMICOLON condFinal .

    ID              reduce using rule 45 (condicion -> IF LPAREN expresion RPAREN cond bloque ELSE condElse bloque SEMICOLON condFinal .)
    IF              reduce using rule 45 (condicion -> IF LPAREN expresion RPAREN cond bloque ELSE condElse bloque SEMICOLON condFinal .)
    PRINT           reduce using rule 45 (condicion -> IF LPAREN expresion RPAREN cond bloque ELSE condElse bloque SEMICOLON condFinal .)
    WHILE           reduce using rule 45 (condicion -> IF LPAREN expresion RPAREN cond bloque ELSE condElse bloque SEMICOLON condFinal .)
    RBRACE          reduce using rule 45 (condicion -> IF LPAREN expresion RPAREN cond bloque ELSE condElse bloque SEMICOLON condFinal .)

